{"0": {
    "doc": "/auth/accesstokenrequest",
    "title": "/auth/accessTokenRequest",
    "content": "This operation is used to retrieve an access token using your API Key and Tradovate credentials. Request . | Property | Tags | Type | Remarks | . | name | required | string | Your Tradovate Username. | . | password | required | string | Your Tradovate Password. | . | appId | required | string | This should match the application nickname you chose when you created your API key | . | appVersion | required | string | Arbitrary string that you can use to track your software version | . | cid | required | number | The entity ID of your Client Application API Key. This will be displayed upon key creation, and above the corresponding API key in the Trader UI. | . | sec | required | string | The API Secret, displayed only one time upon key creation. If you fail to record this value or lose this value it cannot be recovered, and you must create a new API Key. | . | deviceId | none | string | Important value that identifies the device used to make this login attempt. Although any device may request an access token, only approved devices may trade Live Accounts. See the Device ID section for more details. | . Response . AccessTokenResponse . Example . const credentials = { name: 'Your Tradovate Username', password: 'Your Tradovate Password', appId: 'Sample App', appVersion: '1.0', cid: 0, sec: '12345-abcde-...' } async function accessTokenRequest() { let response, data try { response = await fetch('https://live.tradovateapi.com/v1/auth/accessTokenRequest', { method: 'POST', headers: { 'Accept': 'application/json', 'Content-Type': 'application/json' }, body: JSON.stringify(credentials) }) data = await response.json() } catch(err) { console.error(err) } return data } . ",
    "url": "/all-ops/auth/accesstokenrequest#authaccesstokenrequest",
    
    "relUrl": "/all-ops/auth/accesstokenrequest#authaccesstokenrequest"
  },"1": {
    "doc": "/auth/accesstokenrequest",
    "title": "/auth/accesstokenrequest",
    "content": " ",
    "url": "/all-ops/auth/accesstokenrequest",
    
    "relUrl": "/all-ops/auth/accesstokenrequest"
  },"2": {
    "doc": "AccessTokenResponse",
    "title": "AccessTokenResponse",
    "content": "The expected shape of the /auth/accessTokenRequest response. Related . | /auth/accessTokenRequest | /auth/renewAccessToken | . Definition . | Property | Tags | Type | Remarks | . | errorText | none | string | Should the request succeed at the HTTP level, but fail to pass a check on the Tradovate Server this field should be populated. | . | accessToken | none | string | Upon successful response, this field represents the access token that you will use to satisfy the Authentication header in your HTTP requests, and to authenticate WebSockets via the open response. | . | expirationTime | none | Date string | The time after which the access token will be considered ‘expired’. Prior to this time, you can renew your access token using the /auth/renewAccessToken operation | . | passwordExpirationTime | none | Date string |   | . | userStatus | none | \"Active\" \"Closed\" \"Initiated\" \"TemporaryLocked\" \"UnconfirmedEmail\" | Used to determine the state of a User. | . | userId | none | number | The ID of the User to whom the API Key is registered. | . | name | none | string | This field can be used for the accountSpec field in the /order/placeOrder (and family of) operation(s). Mainly used to identify what user is trading an account (multiple users can trade an account given that they have permission to do so). | . | hasLive | none | boolean | Does this user have a funded LIVE account? true if yes. | . ",
    "url": "/entity-system/entity-index/accesstokenresponse",
    
    "relUrl": "/entity-system/entity-index/accesstokenresponse"
  },"3": {
    "doc": "Account",
    "title": "Account",
    "content": "This entity represents a source of equity. A User may have ownership of multiple Account entities. Related . | CashBalance | CashBalanceLog | User | MarginSnapshot | AccountRiskStatus | UserAccountAutoLiq | UserAccountPositionLimit | UserAccountRiskParameter | . Definition . | Property | Tags | Type | Remarks | . | id | none | number, int64 | Account Entity ID. | . | name | required | string, &lt;= 64 chars | Always all-caps with optional underscores and trailing digits. | . | userId | required | number, int64 | Related User Entity ID. | . | accountType | required | string enum, \"Customer\", \"Giveup\", \"House\", \"Omnibus\", \"Wash\" |   | . | active | required | boolean |   | . | clearingHouseId | required | number, int64 |   | . | riskCategoryId | required | number, int64 | The related Risk Category. Typical retail users won’t use this. | . | autoLiqProfileId | required | number, int64 | The UserAccountAutoLiq (Auto Liquidation profile) associated with this account. The Auto Liq profile actually shares the same entity ID as the account since they have a 1:1 relationship. | . | marginAccountType | required | string enum, \"Hedger\", \"Speculator\" |   | . | legalStatus | required | string enum, \"Corporation\", \"GP\", \"IRA\", \"Individual\", \"LLC\", \"LLP\", \"LP\", \"Trust\", \"Joint\" | Typically, retail users are \"Individual\" | . | timestamp | required | Date string |   | . | readonly | none | boolean |   | . ",
    "url": "/entity-system/entity-index/account",
    
    "relUrl": "/entity-system/entity-index/account"
  },"4": {
    "doc": "AccountRiskStatus",
    "title": "AccountRiskStatus",
    "content": "This entity represents the current Risk Status of an account. This entity’s adminAction field can tell you if the account has a locked status. Related . | UserAccountPositionLimit | UserAccountRiskParameter | Account | . Definition . | Property | Tags | Type | Remarks | . | id | none | number, int64 |   | . | adminAction | none | \"AgreedOnLiqOnlyModeByAutoLiq\", \"AgreedOnAutoLiquidationByAutoLiq\", \"DisableAutoLiq\", \"LiquidateImmediately\", \"LiquidateOnlyModeImmediately\", \"LockTradingImmediately\", \"Normal\", \"PlaceAutoLiqOnHold\" |   | . | adminTimestamp | none | Date string |   | . | liquidateOnly | none | Date string |   | . | userTriggeredLiqOnly | none | boolean |   | . ",
    "url": "/entity-system/entity-index/accountriskstatus",
    
    "relUrl": "/entity-system/entity-index/accountriskstatus"
  },"5": {
    "doc": "Accounting",
    "title": "Accounting",
    "content": " ",
    "url": "/all-ops/account",
    
    "relUrl": "/all-ops/account"
  },"6": {
    "doc": "/userPlugin/addEntitlementSubscription",
    "title": "/userPlugin/addEntitlementSubscription",
    "content": "This operation is used to add an entitlement to an organization member. Request . | Property | Tags | Type | Remarks | . | entitlementId | required | number, int64 | The ID of the Entitlement to add. For things like TradingView, for example, a team member will assist by creating an entitlement unique to your organization for the given Entitlement. | . | creditCardId | none | number, int64 | ID of credit card to use for the transaction. Unless users are footing the bill, this should probably not be present. | . | accountId | none | number, int64 | ID of account to use for the transaction. This should be the ID of a LIVE organization DATA account. | . | userId | none | number, int64 | User to add the entitlement to. If not specified, this will default to your admin user. Typically, the intention is to add it for a user, so in practice the ID is required. | . Response . AccessTokenResponse . ",
    "url": "/all-ops/userplugin/addentitlementsubscription#userpluginaddentitlementsubscription",
    
    "relUrl": "/all-ops/userplugin/addentitlementsubscription#userpluginaddentitlementsubscription"
  },"7": {
    "doc": "/userPlugin/addEntitlementSubscription",
    "title": "/userPlugin/addEntitlementSubscription",
    "content": " ",
    "url": "/all-ops/userplugin/addentitlementsubscription",
    
    "relUrl": "/all-ops/userplugin/addentitlementsubscription"
  },"8": {
    "doc": "/user/addMarketDataSubscription",
    "title": "/user/addMarketDataSubscription",
    "content": "This operation is used to: . | Cancel TradovateSubscriptions, MarketDataSubscription | . Request . | Property | Tags | Type | Remarks | . | userId | required | number, int64 | The ID of the associated User to assign the permission to. | . | accountId | required | number, int64 | The ID of the simulation Account to assign permission. | . Response . Object . | Property | Tags | Type | Remarks | . | tradingPermission | required | TradingPermission | Created trading permission. | . ",
    "url": "/all-ops/user/addmarketdatasubscription#useraddmarketdatasubscription",
    
    "relUrl": "/all-ops/user/addmarketdatasubscription#useraddmarketdatasubscription"
  },"9": {
    "doc": "/user/addMarketDataSubscription",
    "title": "/user/addMarketDataSubscription",
    "content": " ",
    "url": "/all-ops/user/addmarketdatasubscription",
    
    "relUrl": "/all-ops/user/addmarketdatasubscription"
  },"10": {
    "doc": "/user/addTradovateSubscription",
    "title": "/user/addTradovateSubscription",
    "content": " ",
    "url": "/all-ops/user/addtradovatesubscription",
    
    "relUrl": "/all-ops/user/addtradovatesubscription"
  },"11": {
    "doc": "Alerts",
    "title": "Alerts",
    "content": " ",
    "url": "/all-ops/alert",
    
    "relUrl": "/all-ops/alert"
  },"12": {
    "doc": "API Operations",
    "title": "All Operations",
    "content": " ",
    "url": "/all-ops#all-operations",
    
    "relUrl": "/all-ops#all-operations"
  },"13": {
    "doc": "API Operations",
    "title": "API Operations",
    "content": " ",
    "url": "/all-ops",
    
    "relUrl": "/all-ops"
  },"14": {
    "doc": "Auth",
    "title": "Auth Operations",
    "content": " ",
    "url": "/all-ops/auth#auth-operations",
    
    "relUrl": "/all-ops/auth#auth-operations"
  },"15": {
    "doc": "Auth",
    "title": "Auth",
    "content": " ",
    "url": "/all-ops/auth",
    
    "relUrl": "/all-ops/auth"
  },"16": {
    "doc": "Authorization Procedure",
    "title": "authorize",
    "content": ". | The authorize operation should be called from a WebSocket immediately after it receives the 'o' or ‘open’ frame from the server. | Unlike the HTTP/REST portion of our API, the WebSocket only needs to be authorized one time. After this point, the connection may be used until closed. | Even after the token expires, the socket will be remain open. However, in case your connection is lost it is a good idea to have some kind of re-connect routine in place. | Try It on our WebSocket Playground! | . Example . //if using node, use node-fetch or axios //retrieve the accessToken from the accessTokenResponse const response = await fetch((TdvLiveURL || TdvDemoUrl) + '/auth/accessTokenRequest') const { accessToken } = await response.json() //if using node, you must add the 'ws' package, from a console: // yarn add ws // or // npm install -s ws const mySocket = new WebSocket(oneOfTradovateWssURLs) let msg_i = 0 mySocket.onopen = _ =&gt; { const authMsg = `authorize\\n${msg_i++}\\n\\n${accessToken}` mySocket.send(authMsg) } . ",
    "url": "/all-ops/websockets/auth#authorize",
    
    "relUrl": "/all-ops/websockets/auth#authorize"
  },"17": {
    "doc": "Authorization Procedure",
    "title": "Authorization Procedure",
    "content": " ",
    "url": "/all-ops/websockets/auth",
    
    "relUrl": "/all-ops/websockets/auth"
  },"18": {
    "doc": "/user/cancelEverything",
    "title": "/user/cancelEverything",
    "content": "This operation is used to: . | Cancel TradovateSubscriptions, MarketDataSubscriptions, and UserPlugins from the LIVE environment. | Cancel TradingPermissions from the Simulation environment. | . Request Body . | Property | Tags | Type | Remarks | . | userIds | required | Array, `int64[]` | An array of IDs of each User entity to cancel. | . Response . Object . | Property | Tags | Type | Remarks | . | tradingPermissionIds | required | Array, `int64[]` | Empty when no TradingPermissions were cancelled. Should be populated from Simulation requests only. | . | marketDataSubscriptionIds | required | Array, `int64[]` | Empty when no MarketDataSubscriptions were cancelled. Should be populated from LIVE requests only. | . | tradovateSubscriptionIds | required | Array, `int64[]` | Empty when no TradovateSubscriptions were cancelled. Should be populated from LIVE requests only. | . | userPluginIds | required | Array, `int64[]` | Empty when no UserPlugins were cancelled. Should be populated from LIVE requests only. | . ",
    "url": "/all-ops/user/canceleverything#usercanceleverything",
    
    "relUrl": "/all-ops/user/canceleverything#usercanceleverything"
  },"19": {
    "doc": "/user/cancelEverything",
    "title": "/user/cancelEverything",
    "content": " ",
    "url": "/all-ops/user/canceleverything",
    
    "relUrl": "/all-ops/user/canceleverything"
  },"20": {
    "doc": "/order/cancelOrder",
    "title": "/order/cancelOrder",
    "content": " ",
    "url": "/all-ops/order/cancelorder",
    
    "relUrl": "/all-ops/order/cancelorder"
  },"21": {
    "doc": "/user/cancelTradovateSubscription",
    "title": "/user/cancelTradovateSubscription",
    "content": " ",
    "url": "/all-ops/user/canceltradovatesubscription",
    
    "relUrl": "/all-ops/user/canceltradovatesubscription"
  },"22": {
    "doc": "CashBalance",
    "title": "CashBalance",
    "content": "An entity that represents a snapshot of an Account’s current balance, daily realized profits/losses and weekly realized profits and losses. Related . | Account | CashBalanceLog | . Definition . | Property | Tags | Type | Remarks | . | id | none | number, int64 |   | . | accountId | required | number, int64 | The account associated with this CashBalance entity. | . | timestamp | required | Date string |   | . | tradeDate | required | TradeDate |   | . | currencyId | required | number, int64 |   | . | amount | required | number, double | The value in currency of type currencyId represented by this CashBalance entity. | . | realizedPnL | none | number, double | The realized P&amp;L for the current session, resets between session close and open. | . | weekRealizedPnL | none | number, double | The realized P&amp;L for the week resetting at week open (for ES and similar, Sunday 6PM - Friday 5PM). | . ",
    "url": "/entity-system/entity-index/cashbalance",
    
    "relUrl": "/entity-system/entity-index/cashbalance"
  },"23": {
    "doc": "CashBalanceLog",
    "title": "CashBalanceLog",
    "content": "Represents a transactional change in an Account’s CashBalance. Related . | Account | CashBalance | . Definition . | Property | Tags | Type | Remarks | . | id | none | number, int64 |   | . | accountId | required | number, int64 | ID of the associated Account entity. | . | timestamp | required | Date string | Time that this log was generated. | . | tradeDate | required | TradeDate |   | . | currencyId | required | number, int64 |   | . | amount | required | number, double | The decimal amount in Currency of type currencyId that the associated Account is holding. | . | realizedPnL | none | number, double | Realized profits &amp; losses for the current session at the time this log was generated. Resets daily between 5-6PM EST | . | weekRealizedPnL | none | number, double | Realized profits &amp; losses for the trading week at the time this log was generated. Resets Sunday 6PM EST. | . | cashChangeType | required | string enum, \"AutomaticReconciliation\" \"BrokerageFee\" \"CancelledPairedTrade\" \"ClearingFee\" \"Commission\" \"DeskFee\" \"EntitlementSubscription\" \"ExchangeFee\" \"FundTransaction\" \"FundTransactionFee\" \"IPFee\" \"LiquidationFee\" \"ManualAdjustment\" \"MarketDataSubscription\" \"NewSession\" \"NfaFee\" \"OptionsTrade\" \"OrderRoutingFee\" \"TradePaired\" \"TradovateSubscription\" | The type of transaction or fee that this log represents or was generated for. | . | fillPairId | none | number, int64 | If this log was generated as the result of a Fill being paired (position closing) this field will be present and its value will be equal to the ID of the related FillPair entity. | . | fillId | none | number, int64 | If this log was generated as the result of a order being filled, this field will be present and its value will be equal to the ID of the related Fill entity. | . | fundTransactionId | none | number, int64 |   | . | delta | required | number, double | A decimal representing the change in Currency of type currencyId that this transaction or fee represents. Negative values represent negative change, and vice versa. | . | senderId | none | number, int64 |   | . | comment | label | string &lt;= 64 chars |   | . ",
    "url": "/entity-system/entity-index/cashbalancelog",
    
    "relUrl": "/entity-system/entity-index/cashbalancelog"
  },"24": {
    "doc": "CashBalanceSnapshot",
    "title": "CashBalanceSnapshot",
    "content": "A snapshot of an Account’s balance at the time of the request. Related . | CashBalance | Account | . Definition . | Property | Tags | Type | Remarks | . | errorText | none | string | Non-empty if the request failed. | . | totalCashValue | none | number |   | . | totalPnL | none | number | May not be included if none of the other PnL fields are filled. | . | initialMargin | none | number |   | . | maintenanceMargin | none | number |   | . | netLiq | none | number |   | . | openPnL | none | number | May not be included if you do not have an open position. | . | realizedPnL | none | number | May not be included if you have not opened and closed a trade during the session. | . | weekRealizedPnL | none | number | May not be included if you have not opened and closed a trade yet this week. | . ",
    "url": "/entity-system/entity-index/cashbalancesnapshot",
    
    "relUrl": "/entity-system/entity-index/cashbalancesnapshot"
  },"25": {
    "doc": "Cash Balance",
    "title": "Cash Balance",
    "content": " ",
    "url": "/all-ops/cashbalance",
    
    "relUrl": "/all-ops/cashbalance"
  },"26": {
    "doc": "/cashBalance/changeDemoBalance",
    "title": "/cashBalance/changeDemoBalance",
    "content": "Change a Simulation Account’s cash balance. Related . | CashBalance | /userAccountAutoLiq/update | . Request . | Property | Tags | Type | Remarks | . | accountId | required | number, int64 | SIM Account to change. | . | cashChange | required | number, double | Cash amount to change balance by. Accepts negative numbers for negative balance changes. | . Notes . | When using this operation, be aware that the associated AccountRiskStatus’s maxNetLiq field will be affected by this change. If you add $1,000.00 to an account with a Trailing Max Drawdown applied, the drawdown level will move accordingly. | . ",
    "url": "/all-ops/cashbalance/changedemobalance#cashbalancechangedemobalance",
    
    "relUrl": "/all-ops/cashbalance/changedemobalance#cashbalancechangedemobalance"
  },"27": {
    "doc": "/cashBalance/changeDemoBalance",
    "title": "/cashBalance/changeDemoBalance",
    "content": " ",
    "url": "/all-ops/cashbalance/changedemobalance",
    
    "relUrl": "/all-ops/cashbalance/changedemobalance"
  },"28": {
    "doc": "/user/changePluginPermission",
    "title": "/user/changePluginPermission",
    "content": " ",
    "url": "/all-ops/user/changepluginpermission",
    
    "relUrl": "/all-ops/user/changepluginpermission"
  },"29": {
    "doc": "replay/changeSpeed",
    "title": "replay/changeSpeed",
    "content": ". | This operation is used to change the speed of a Market Replay session. | The operation is only valid when using a Market Replay Socket (a WebSocket connected to the Market Replay URL, wss://replay.tradovateapi.com/v1/websocket) | Can be useful to reset a throttled replay session. | The maximum replay speed available is 400% original speed. | . Example . const myReplaySocket = new WebSocket('wss://replay.tradovateapi.com/v1/websocket') let msg_i = 0 //... //perform the auth procedure. See the WebSockets Authorization Procedure for more details //... myReplaySocket.onmessage = msg =&gt; { const T = msg.data.split(0,1) //first char is frame type let data = msg.data.split(1) //data is rest if(data) { //parse to JSON, all data arrives as a string representation of a JSON array data = JSON.parse(data) } //'a' is the data frame type if(T === 'a') { const { e, d } = data //clock events synchronize replay time w client if(e === 'clock') { //clock event data is a JSON string const { s, t } = JSON.parse(d) //'s' is the speed, 't' is the timestamp. If 's' is 0 the speed has been throttled. if(s === 0) { const msg = `replay/changeSpeed\\n${msg_i++}\\n\\n${JSON.stringify({speed:400})}` myReplaySocket.send(msg) } } } } . ",
    "url": "/wss-guide/market-replay/change-speed",
    
    "relUrl": "/wss-guide/market-replay/change-speed"
  },"30": {
    "doc": "replay/checkReplaySession",
    "title": "replay/checkReplaySession",
    "content": ". | The checkReplaySession operation is used to determine if a Market Replay session is within the scope of your User’s permission to request. | This operation should be called before attempting to connect to a Market Replay session using the replay/initializeClock operation. | . Example . const myReplaySocket = new WebSocket('wss://replay.tradovateapi.com/v1/websocket') let msg_i = 0 //... //perform the auth procedure. See the WebSockets Authorization Procedure for more details //... const body = { startTimestamp: new Date('2021-05-03Z18:00').toJSON() } const msg = `replay/checkReplaySession\\n${msg_i++}\\n\\n${JSON.stringify(body)}` myReplaySocket.send(msg) . ",
    "url": "/wss-guide/market-replay/check-replay-session",
    
    "relUrl": "/wss-guide/market-replay/check-replay-session"
  },"31": {
    "doc": "CheckReplaySessionResponse",
    "title": "CheckReplaySessionResponse",
    "content": "The server response when calling the replay/checkReplaySession operation. This operation is only available for and intended for use with the Tradovate WebSocket APIs. Related . Definition . | Property | Tags | Type | Remarks | . | checkStatus | required | \"Ineligible\" \"OK\" \"StartTimestampAdjusted\" |   | . | startTimestamp | none | Date string | Not included if the checkStatus === \"OK\". | . Notes . | You should call this function before you make a call to replay/initializeClock. | If the timestamp is adjusted, be sure to make note of it and handle it in your code. Problems can occur when the adjusted timestamp is more recent than the time you want your replay session to end. In this scenario, you’ll likely never receive the correct clock event you need to determine the session should end, or your session will be ended immediately since it will receive an initial clock response beyond your provided end time. | . Example Usage . const URL = 'wss://replay.tradovateapi.com/v1/websocket' const myMarketReplaySocket = new WebSocket(URL) //simple WebSocket authorization procedure myMarketReplaySocket.onopen = function() { myMarketReplaySocket.send(`authorize\\n0\\n\\n${accessToken}`) } //JSON string for midnight April 30th 2018 const startTimestamp = new Date('2018-04-30').toJSON() myMarketReplaySocket.send(`replay/checkreplaysession\\n1\\n\\n${JSON.stringify({startTimestamp})}`) //listen for response myMarketReplaySocket.addEventListener('message', msg =&gt; { const datas = JSON.parse(msg.data.slice(1)) //chop off leading 'frame' char //datas looks like this [{s: 200, i: 1, d: { checkStatus: 'OK' } }] if(datas) { datas.forEach(({i, d}) =&gt; { if(i &amp;&amp; i === 1) { //id of our sent message is 1, response's `i` field will be 1. console.log(d) //=&gt; { checkStatus: 'OK' } //if the status is OK we can send the initializeClock message } }) } }) . ",
    "url": "/entity-system/entity-index/checkreplaysessionresponse",
    
    "relUrl": "/entity-system/entity-index/checkreplaysessionresponse"
  },"32": {
    "doc": "Command",
    "title": "Command",
    "content": "Whenever a user places an order, what they’re actually doing is creating a Command to place that order. A Command entity represents an attempt to take a trading action. Related . | CommandReport | ExecutionReport | Order | . Definition . | Property | Tags | Type | Remarks | . | id | none | number, int64 |   | . | orderId | required | number, int64 | ID of the associated Order entity that this command was generated for. | . | timestamp | required | Date string | Time that this Command was generated. | . | clOrdId | none | string |   | . | commandType | required | string enum, \"Cancel\" \"Modify\" \"New\" | The three actions basic actions that a Command can represent for an order. | . | commandStatus | required | string enum, \"AtExecution\" \"ExecutionRejected\" \"ExecutionStopped\" \"ExecutionSuspended\" \"OnHold\" \"Pending\" \"PendingExecution\" \"Replaced\" \"RiskPassed\" \"RiskRejected\" | The current status of a Command. Please use CommandReports to monitor the Command’s lifecycle instead of using this property directly. | . | senderId | none | number, int64 | User ID of sending user, if applicable. | . | userSessionId | none | number, int64 |   | . | activationTime | none | Date string | Optional time that this Command is set to fire, otherwise fires ASAP. | . | customTag50 | none | string &lt;= 50 chars | Optional string up to 50 characters to describe this Command. | . | isAutomated | none | boolean | If the Command was generated by an application without the intervention of a human, isAutomated must be true. | . ",
    "url": "/entity-system/entity-index/command",
    
    "relUrl": "/entity-system/entity-index/command"
  },"33": {
    "doc": "CommandReport",
    "title": "CommandReport",
    "content": "Once a Command has been sent by a client, the server begins processing that request. As the command is processed, its status is updated. The CommandReport entity can be used as a mechanism for digesting those updates. Related . | Command | ExecutionReport | . Definition . | Property | Tags | Type | Remarks | . | id | none | number, int64 |   | . | commandId | required | number, int64 | ID of the associated Command entity. | . | timestamp | required | Date string | Time that this CommandReport was generated. | . | commandStatus | required | string enum, \"AtExecution\" \"ExecutionRejected\" \"ExecutionStopped\" \"ExecutionSuspended\" \"OnHold\" \"Pending\" \"PendingExecution\" \"Replaced\" \"RiskPassed\" \"RiskRejected\" | Use this status to determine the status of a Command. | . | rejectReason | none | string enum, \"AccountClosed\" \"AdvancedTrailingStopUnsupported\" \"AnotherCommandPending\" \"BackMonthProhibited\" \"ExecutionProviderNotConfigured\" \"ExecutionProviderUnavailable\" \"InvalidContract\" \"InvalidPrice\" \"LiquidationOnly\" \"LiquidationOnlyBeforeExpiration\" \"MaxOrderQtyIsNotSpecified\" \"MaxOrderQtyLimitReached\" \"MaxPosLimitMisconfigured\" \"MaxPosLimitReached\" \"MaxTotalPosLimitReached\" \"MultipleAccountPlanRequired\" \"NoQuote\" \"NotEnoughLiquidity\" \"OtherExecutionRelated\" \"ParentRejected\" \"RiskCheckTimeout\" \"SessionClosed\" \"Success\" \"TooLate\" \"TradingLocked\" \"TrailingStopNonOrderQtyModify\" \"Unauthorized\" \"UnknownReason\" \"Unsupported\" | Can help to determine why a Command failed. | . | text | none | string &lt;= 8192 chars | Optional descriptive text associated with the Command. | . | ordStatus | none | string enum, \"Canceled\" \"Completed\" \"Expired\" \"Filled\" \"PendingCancel\" \"PendingNew\" \"PendingReplace\" \"Rejected\" \"Suspended\" \"Unknown\" \"Working\" | You can use this field to determine the status of a related order. | . ",
    "url": "/entity-system/entity-index/commandreport",
    
    "relUrl": "/entity-system/entity-index/commandreport"
  },"34": {
    "doc": "CommandResult",
    "title": "CommandResult",
    "content": "Response from order/cancelOrder or order/modifyOrder operations. Related . | Command | CommandReport | ExecutionReport | . Definition . | Property | Tags | Type | Remarks | . | failureReason | none | \"AccountClosed\" \"AdvancedTrailingStopUnsupported\" \"AnotherCommandPending\" \"BackMonthProhibited\" \"ExecutionProviderNotConfigured\" \"ExecutionProviderUnavailable\" \"InvalidContract\" \"InvalidPrice\" \"LiquidationOnly\" \"LiquidationOnlyBeforeExpiration\" \"MaxOrderQtyIsNotSpecified\" \"MaxOrderQtyLimitReached\" \"MaxPosLimitMisconfigured\" \"MaxPosLimitReached\" \"MaxTotalPosLimitReached\" \"MultipleAccountPlanRequired\" \"NoQuote\" \"NotEnoughLiquidity\" \"OtherExecutionRelated\" \"ParentRejected\" \"RiskCheckTimeout\" \"SessionClosed\" \"Success\" \"TooLate\" \"TradingLocked\" \"TrailingStopNonOrderQtyModify\" \"Unauthorized\" \"UnknownReason\" \"Unsupported\" |   | . | failureText | none | string | Non-empty if the request passed at the HTTP level, but failed a check on the server. | . | commandId | none | number | Non-empty if the Command succeeded. | . ",
    "url": "/entity-system/entity-index/commandresult",
    
    "relUrl": "/entity-system/entity-index/commandresult"
  },"35": {
    "doc": "/adminAlertSignal/completeAlertSignal",
    "title": "/adminAlertSignal/completeAlertSignal",
    "content": " ",
    "url": "/all-ops/adminalertsignal/completealertsignal",
    
    "relUrl": "/all-ops/adminalertsignal/completealertsignal"
  },"36": {
    "doc": "ContactInfo",
    "title": "ContactInfo",
    "content": "An entity to hold a User’s Contact Information. A user’s contact information shouldn’t contain any special characters. Related . | User | . Definition . | Property | Tags | Type | Remarks | . | id | none | number |   | . | userId | required | number | ID of related User entity. | . | firstName | required | string | Up to 64 characters. | . | lastName | required | string | Between 2 and 64 characters. | . | streetAddress1 | required | string | Between 3 and 61 characters. | . | streetAddress2 | none | string | Up to 61 characters. | . | city | required | string | 2 to 35 characters. | . | state | none | string | 2 to 64 characters. | . | postCode | none | string | 4 to 11 characters. | . | country | required | string | 2 character country code. | . | phone | required | string | 10-21 characters. | . | mailingIsDifferent | none | boolean | Indicates the User’s mailing address is not their provided street address. | . | mailingStreetAddress1 | none | string |   | . | mailingStreetAddress2 | none | string |   | . | mailingCity | none | string |   | . | mailingState | none | string |   | . | mailingPostCode | none | string |   | . | mailingCountry | none | string |   | . ",
    "url": "/entity-system/entity-index/contactinfo",
    
    "relUrl": "/entity-system/entity-index/contactinfo"
  },"37": {
    "doc": "Contract",
    "title": "Contract",
    "content": "Simple object to represent a Contract. Related . | Product | . Definition . | Property | Tags | Type | Remarks | . | id | none | number, int64 |   | . | name | required | string &lt;= 64 chars | Name of this contract, consists of Product Code (like ES or NQ) and expiration code (M2, Z4, H1, etc). So for example for an ES contract expiring June of 2027 we would use ESM7 for its contract name. | . | contractMaturityId | required | number, int64 |   | . ",
    "url": "/entity-system/entity-index/contract",
    
    "relUrl": "/entity-system/entity-index/contract"
  },"38": {
    "doc": "ContractGroup",
    "title": "ContractGroup",
    "content": "Simple object to represent a category of Contract. Related . Definition . | Property | Tags | Type | Remarks | . | id | none | number, int64 |   | . | name | required | string &lt;= 64 chars |   | . ",
    "url": "/entity-system/entity-index/contractgroup",
    
    "relUrl": "/entity-system/entity-index/contractgroup"
  },"39": {
    "doc": "Contract Library",
    "title": "Contract Library",
    "content": " ",
    "url": "/all-ops/contract",
    
    "relUrl": "/all-ops/contract"
  },"40": {
    "doc": "ContractMargin",
    "title": "ContractMargin",
    "content": "Simple object to represent a Contract’s margin requirements. Related . | Contract | ContractMaturity | . Definition . | Property | Tags | Type | Remarks | . | id | none | number, int64 |   | . | initialMargin | required | number, double |   | . | maintenanceMargin | required | number, double |   | . | timestamp | required | Date string |   | . ",
    "url": "/entity-system/entity-index/contractmargin",
    
    "relUrl": "/entity-system/entity-index/contractmargin"
  },"41": {
    "doc": "ContractMaturity",
    "title": "ContractMaturity",
    "content": "Object that represents a contract’s maturity information, including the expiration month and specific date, product ID, and whether or not this is the front-month contract. Related . | Contract | ContractMargin | . Definition . | Property | Tags | Type | Remarks | . | id | none | number, int64 |   | . | productId | required | number, int64 |   | . | expirationMonth | required | number, [1..12] |   | . | expirationDate | required | Date string |   | . | firstIntentDate | none | Date string |   | . | underlyingId | none | number, int64 |   | . | isFront | required | boolean | This may seem very useful at a glance for determining which contract to trade in an automated strategy, however this value will not change until the current front-month contract expires. Instead use the /&lt;entity&gt;/suggest operation. | . ",
    "url": "/entity-system/entity-index/contractmaturity",
    
    "relUrl": "/entity-system/entity-index/contractmaturity"
  },"42": {
    "doc": "/alert/createAlert",
    "title": "/alert/createAlert",
    "content": "Notes . Example expression: . { \"conjuction\":\"OR\", \"conditions\":[ { \"l\":\"percentChange\", \"op\":\"&gt;\", \"r\":\"0.27506876719179796\", \"rf\":\"0.28\", \"subj\":\"ESH3\" }, { \"l\":\"posOpenPLUsd\", \"op\":\"&gt;\", \"r\":\"100\", \"subj\":\"[object Object]|ESH3\" }, { \"l\":\"cashAmount\", \"op\":\"&lt;\", \"r\":\"47400\", \"subj\":\"DEMO15460\" } ] } . ",
    "url": "/all-ops/alert/createalert",
    
    "relUrl": "/all-ops/alert/createalert"
  },"43": {
    "doc": "/user/createTradingPermission",
    "title": "/user/createTradingPermission",
    "content": "This operation is used to create a TradingPermission from a userId and and accountId. Request . | Property | Tags | Type | Remarks | . | userId | required | number, int64 | The ID of the associated User to assign the permission to. | . | accountId | required | number, int64 | The ID of the simulation Account to assign permission. | . Response . Object . | Property | Tags | Type | Remarks | . | tradingPermission | required | TradingPermission | Created trading permission. | . ",
    "url": "/all-ops/user/createtradingpermission#usercreatetradingpermission",
    
    "relUrl": "/all-ops/user/createtradingpermission#usercreatetradingpermission"
  },"44": {
    "doc": "/user/createTradingPermission",
    "title": "/user/createTradingPermission",
    "content": " ",
    "url": "/all-ops/user/createtradingpermission",
    
    "relUrl": "/all-ops/user/createtradingpermission"
  },"45": {
    "doc": "Currency",
    "title": "Currency",
    "content": "Representation of a currency like USD, JPY or EUR. Related . | CurrencyRate | Account | CashBalance | CashBalanceLog | . Definition . | Property | Tags | Type | Remarks | . | id | none | number, int64 |   | . | name | required | string &lt;= 64 chars |   | . | symbol | label | string &lt;= 64 chars |   | . ",
    "url": "/entity-system/entity-index/currency",
    
    "relUrl": "/entity-system/entity-index/currency"
  },"46": {
    "doc": "CurrencyRate",
    "title": "CurrencyRate",
    "content": "Related . | Currency | Account | CashBalance | CashBalanceLog | . Definition . | Property | Tags | Type | Remarks | . | id | none | number, int64 |   | . | timestamp | required | Date string |   | . | rate | required | number, double |   | . ",
    "url": "/entity-system/entity-index/currencyrate",
    
    "relUrl": "/entity-system/entity-index/currencyrate"
  },"47": {
    "doc": "DeleteResultResponse",
    "title": "DeleteResultResponse",
    "content": "The message received when using either the userAccountPositonLimit/deleteUserAccountPositionLimit or userAccountRiskParameter/deleteUserAccountRiskParameter operations. Related . | UserAccountPositionLimit | UserAccountRiskParameter | UserAccountAutoLiq | . Definition . | Property | Tags | Type | Remarks | . | errorText | none | string | Non-empty if the request failed. | . | success | none | boolean |   | . ",
    "url": "/entity-system/entity-index/deleteresultresponse",
    
    "relUrl": "/entity-system/entity-index/deleteresultresponse"
  },"48": {
    "doc": "/userAccountPositionLimit/deleteUserAccountPositionLimit",
    "title": "/userAccountPositionLimit/deleteUserAccountPositionLimit",
    "content": " ",
    "url": "/all-ops/risks/deleteuseraccountpositionlimit",
    
    "relUrl": "/all-ops/risks/deleteuseraccountpositionlimit"
  },"49": {
    "doc": "/userAccountPositionLimit/deleteUserAccountRiskParameter",
    "title": "/userAccountPositionLimit/deleteUserAccountRiskParameter",
    "content": " ",
    "url": "/all-ops/risks/deleteuseraccountriskparameter",
    
    "relUrl": "/all-ops/risks/deleteuseraccountriskparameter"
  },"50": {
    "doc": "/deps",
    "title": "/{entity}/deps",
    "content": "This operation is used to look up entities of this type that are dependent on another ‘master’ entity. ",
    "url": "/all-ops/shared/deps#entitydeps",
    
    "relUrl": "/all-ops/shared/deps#entitydeps"
  },"51": {
    "doc": "/deps",
    "title": "Format",
    "content": "For HTTP requests, we can use this format: . https://live.tradovateapi.com/v1/{entity}/deps?masterid={item_id} OR https://demo.tradovateapi.com/v1/{entity}/deps?masterid={item_id} . And for WebSocket requests: . &lt;entity&gt;/deps &lt;msg_id&gt; masterid=&lt;entity_id&gt; . Example Usage: . async function entityDeps(entityType, masterid) { const URL = `https://demo.tradovateapi.com/v1/${entityType}/deps?masterid=${masterid}` const config let response, data try { response = await fetch(URL) data = await response.json() } catch(err) { console.error(err) } return data } await entityDeps('contractMaturity', 814) //=&gt; // [ // { // \"id\": 37215, // \"productId\": 814, // \"expirationMonth\": 201712, // \"expirationDate\": \"2017-12-15T22:29Z\", // \"archived\": false, // \"seqNo\": 10, // \"isFront\": false // }, // { // \"id\": 37417, // \"productId\": 814, // \"expirationMonth\": 201803, // \"expirationDate\": \"2018-03-16T21:29Z\", // \"archived\": false, // \"seqNo\": 11, // \"isFront\": false // }, // //... // ] . Notes . | masterid Entity Type | Related Entity Types | . | (The entity type that should be used for masterid parameter) | (The operation’s returned type) | . | Account | CashBalance CashBalanceLog MarginSnapshot AccountRiskStatus UserAccountAutoLiq Position Order OrderStrategy User UserAccountPositionLimit | . | Command | CommandReport ExecutionReport | . | Contract | ContractMaturity | . | Product | ProductMargin ContractMaturity ProductSession | . | Order | Command OrderVersion Fill | . | Exchange | Product | . | OrderStrategy | OrderStrategyLink | . | Fill | FillFee | . | Position | FillPair | . | User | Account TradingPermission ContactInfo | . | UserAccountPositionLimit | UserAccountRiskParameter | . ",
    "url": "/all-ops/shared/deps#format",
    
    "relUrl": "/all-ops/shared/deps#format"
  },"52": {
    "doc": "/deps",
    "title": "/deps",
    "content": " ",
    "url": "/all-ops/shared/deps",
    
    "relUrl": "/all-ops/shared/deps"
  },"53": {
    "doc": "Entities are Related",
    "title": "Entities Are Related",
    "content": "Many entities are related to other entities. You can usually tell when an entity has a relationship with another based on its fields - an entity with relationships will typically store the IDs of the related entities in its own fields. For example, if you look at the Account entity, you’ll see there is a userId field for the related User entity, a clearingHouseId for whatever clearing house the account uses, riskCategoryId for the risk category that this Account belongs to, and an autoLiqProfileId for the related Auto-Liquidation Profile. Understanding how entities relate to one another can be very helpful for understanding how the API works in general. Please refer to the Entities Index for a dictionary of Tradovate API Entities and response object schemas. Here is an example of how to get all of the Order entities related to a given Account. async function findRelatedOrders(accountId) { const { accessToken } = Storage.getUserData() let response try { response = await fetch(`https://demo.tradovateapi.com/v1/order/deps?masterid=${accountId}`, { method: 'GET', headers: buildHeaders(accessToken) }) response = await response.json() } catch(err) { console.error(err) } return response } . The Entity System Shared Operations . ",
    "url": "/entity-system/entities-are-related/#entities-are-related",
    
    "relUrl": "/entity-system/entities-are-related/#entities-are-related"
  },"54": {
    "doc": "Entities are Related",
    "title": "Entities are Related",
    "content": " ",
    "url": "/entity-system/entities-are-related/",
    
    "relUrl": "/entity-system/entities-are-related/"
  },"55": {
    "doc": "Common Operations",
    "title": "Common Entity Operations",
    "content": "Please see the API Operations section to see details about each of the shared API operations. Although there are many unique operations available via API, all entities share seven basic operations. These operations are valid (with a few exceptions) for any entity you call them on. The format of these calls via HTTP looks like this: . https://&lt;prefix&gt;.tradovateapi.com/v1/&lt;entity&gt;/&lt;operation&gt; . Where &lt;prefix&gt; is either ‘live’ or ‘demo’, &lt;entity&gt; would be replaced with a valid entity type name (cashBalance, account, productMargin, etc.), and &lt;operation&gt; is one of the following seven operations. ",
    "url": "/entity-system/shared-ops/#common-entity-operations",
    
    "relUrl": "/entity-system/shared-ops/#common-entity-operations"
  },"56": {
    "doc": "Common Operations",
    "title": "/list",
    "content": "/list is the simplest request to make, as it has no parameters. Simply by having a valid accessToken in the header, we will be able to retrieve lists of the given entity with a GET request. /list will return every entity of the given type within the scope of your User’s permissions. So if we call /account/list we will retrieve a list of Account entities associated with the User making that request. ",
    "url": "/entity-system/shared-ops/#list",
    
    "relUrl": "/entity-system/shared-ops/#list"
  },"57": {
    "doc": "Common Operations",
    "title": "/find",
    "content": "The /find operation is used for finding entities that have a name field. It will ‘work’ on entities that don’t have a name field, but it will never return anything. So, if you’re having trouble with this operation, ensure the entity type you are searching has a name. The /find operation takes a single query parameter, name formatted like so - /find?name=&lt;entity_name&gt;. To find the ES contract expiring June 2022, we would use /contract/find?name=ESM2. ",
    "url": "/entity-system/shared-ops/#find",
    
    "relUrl": "/entity-system/shared-ops/#find"
  },"58": {
    "doc": "Common Operations",
    "title": "/item",
    "content": "The /item operation is useful for finding an entity for which you already know the entity ID. A common example would be looking up the Contract related to an Order. The Order entity has a field called contractId that we would use /contract/item?id=&lt;contractId&gt; to retrieve the Contract instance. ",
    "url": "/entity-system/shared-ops/#item",
    
    "relUrl": "/entity-system/shared-ops/#item"
  },"59": {
    "doc": "Common Operations",
    "title": "/items",
    "content": "Just like /item except instead of using the singular id as a parameter, we have ids. ids should consist of a comma-separated list of integer IDs, eg. 12345,23456,34567. This is most useful when you want to get several entities of the same type by their IDs in a single API call. ",
    "url": "/entity-system/shared-ops/#items",
    
    "relUrl": "/entity-system/shared-ops/#items"
  },"60": {
    "doc": "Common Operations",
    "title": "/deps",
    "content": "/deps is an operation that retrieves entities of a given type related to a ‘master’ entity of another type. For more info on which entities are related, see the Notes section of the /deps page. ",
    "url": "/entity-system/shared-ops/#deps",
    
    "relUrl": "/entity-system/shared-ops/#deps"
  },"61": {
    "doc": "Common Operations",
    "title": "/ldeps",
    "content": "Just like /deps except instead of the singular masterid parameter, we need to use the plural masterids parameter. Much like /items, /ldeps takes the masterids as a comma-separated list of integer IDs. ",
    "url": "/entity-system/shared-ops/#ldeps",
    
    "relUrl": "/entity-system/shared-ops/#ldeps"
  },"62": {
    "doc": "Common Operations",
    "title": "/suggest",
    "content": "When you want to find out what entities are available or search for choices, you can use the /suggest operation. It takes two query parameters, t and l. t is the text to search and l is the maximum number of results to return. Useful for things like searching for available contract expirations. Entities are Related . ",
    "url": "/entity-system/shared-ops/#suggest",
    
    "relUrl": "/entity-system/shared-ops/#suggest"
  },"63": {
    "doc": "Common Operations",
    "title": "Common Operations",
    "content": " ",
    "url": "/entity-system/shared-ops/",
    
    "relUrl": "/entity-system/shared-ops/"
  },"64": {
    "doc": "The Entity System",
    "title": "The Entity System",
    "content": " ",
    "url": "/entity-system/",
    
    "relUrl": "/entity-system/"
  },"65": {
    "doc": "The Entity System",
    "title": "Understanding the Tradovate API Entity System",
    "content": "The Tradovate API’s backend is a well organized and fine-tuned market data processing machine (and more). To keep things in order, we employ an Entity System defining all the possible types of ‘things’ that can exist within the application-space. As we are a futures-trading platform, we have such entities as Order, Contract, ContractMaturity, CashBalance, Account, and so on. Each of these entities has a different interface, or shape. Entities can be related, and they also share a set of common operations that will work (mostly) for all entity types. As we send and receive data from the Tradovate servers, we will be encountering and utilizing objects of these types. Explore Entities Entities Are Related . ",
    "url": "/entity-system/#understanding-the-tradovate-api-entity-system",
    
    "relUrl": "/entity-system/#understanding-the-tradovate-api-entity-system"
  },"66": {
    "doc": "Entities Index",
    "title": "Entities Index",
    "content": "This section contains a list of Tradovate Entities’ definitions and usage assistance. ",
    "url": "/entity-system/entity-index/",
    
    "relUrl": "/entity-system/entity-index/"
  },"67": {
    "doc": "Entitlement",
    "title": "Entitlement",
    "content": "Object to represent an Entitlement. This is the basis of a UserPlugin. Related . | EntitlementSubscription | EntitlementSubscriptionResponse | UserPlugin | /userPlugin/addEntitlementSubscription | . Definition . | Property | Tags | Type | Remarks | . | id | none | number, int64 |   | . | title | required | string &lt;= 64 chars | Display name for this Entitlement. | . | price | required | number, double | Price of the Entitlement. | . | startDate | label | TradeDate | Represents the date that this Entitlement was or will become available. | . | discontinuedDate | label | TradeDate | Represents the date that this Entitlement was discontinued and made no longer available. Requests to add a discontinued Entitlement will fail. | . | name | required | string &lt;= 64 chars | Reference name for this Entitlement, used for things like the /find operation. | . | duration | label | number, int32 | Duration in durationUnits that a paid-period for the associated EntitlementSubscription should last. | . | durationUnits | label | string enum, \"Month\" \"Quarter\" \"Week\" \"Year\" | Unit by which duration should be measured. | . | autorenewal | label | boolean | true if the associated EntitlementSubscription should automatically renew. | . ",
    "url": "/entity-system/entity-index/entitlement",
    
    "relUrl": "/entity-system/entity-index/entitlement"
  },"68": {
    "doc": "EntitlementSubscription",
    "title": "EntitlementSubscription",
    "content": "Related . | Entitlement | EntitlementSubscriptionResponse | /userPlugin/addEntitlementSubscription | . Definition . | Property | Tags | Type | Remarks | . | id | none | number, int64 |   | . | userId | required | number, int64 |   | . | timestamp | required | Date string | Creation timestamp. | . | planPrice | required | number, double |   | . | creditCardTransactionId | label | number, int64 | Non-null if a credit card was used to purchase this entitlement. | . | cashBalanceLogId | label | number, int64 | Non-null if a Tradovate account was used to purchase this entitlement. | . | creditCardId | label | number, int64 | Non-null if a credit card was used to purchase this entitlement. | . | accountId | label | number, int64 | Non-null if a Tradovate account was used to purchase this entitlement. | . | pluginName | required | string &lt;= 64 chars | Name of the UserPlugin that this entitlement grants. | . | approval | required | boolean | true when the entitlement is active. | . | entitlementId | label | number, int64 | Entitlement | . | startDate | required | TradeDate | Purchase date as a TradeDate object. | . | expirationDate | label | TradeDate | Expiration date as a TradeDate object. Null implies no expiration. | . | paidAmount | required | number, double | Paid price for this entitlement. | . | autorenewal | label | boolean | true if this entitlement subscription automatically renews. | . | planCategories | label | string &lt;= 8192 chars | ; delimited string of plans that are allowed to purchase this entitlement. | . ",
    "url": "/entity-system/entity-index/entitlementsubscription",
    
    "relUrl": "/entity-system/entity-index/entitlementsubscription"
  },"69": {
    "doc": "EntitlementSubscriptionResponse",
    "title": "EntitlementSubscriptionResponse",
    "content": "Expected response from the /userPlugin/addEntitlementSubscription operation. Definition . | Property | Tags | Type | Remarks | . | errorText | none | string &lt;= 8192 chars | Non-empty if the request failed. | . | errorCode | none | Enum, \"ConflictWithExisting\" \"DowngradeNotAllowed\" \"IncompatibleCMEMarketDataSubscriptionPlans\" \"IncorrectPaymentMethod\" \"InsufficientFunds\" \"PaymentProviderError\" \"PlanDiscontinued\" \"SingleTrialOnly\" \"Success\" \"UnknownError\" |   | . | entitlementSubscription | none | EntitlementSubscription |   | . ",
    "url": "/entity-system/entity-index/entitlementsubscriptionresponse",
    
    "relUrl": "/entity-system/entity-index/entitlementsubscriptionresponse"
  },"70": {
    "doc": "ExecutionReport",
    "title": "ExecutionReport",
    "content": "An object that represents the Execution of a Command. Related . | Command | CommandReport | . Definition . | Property | Tags | Type | Remarks | . | id | none | number, int64 |   | . | commandId | required | number, int64 | The entity ID of the associated Command. | . | name | required | string &lt;= 64 chars |   | . | accountId | required | number, int64 | The entity ID of the associated Account. | . | contractId | required | number, int64 | The entity ID of the associated Contract. | . | timestamp | required | Date string |   | . | tradeDate | none | TradeDate |   | . | orderId | required | number, int64 | The entity ID of the associated Order | . | execType | required | \"Canceled\" \"Completed\" \"DoneForDay\" \"Expired\" \"New\" \"OrderStatus\" \"PendingCancel\" \"PendingNew\" \"PendingReplace\" \"Rejected\" \"Replaced\" \"Stopped\" \"Suspended\" \"Trade\" \"TradeCancel\" \"TradeCorrect\" |   | . | execRefId | none | string &lt;= 64 chars |   | . | ordStatus | none | string enum, \"Canceled\" \"Completed\" \"Expired\" \"Filled\" \"PendingCancel\" \"PendingNew\" \"PendingReplace\" \"Rejected\" \"Suspended\" \"Unknown\" \"Working\" | Status of the associated Order. | . | action | required | string enum, \"Buy\" \"Sell\" |   | . | cumQty | none | number, int32 |   | . | avgPx | none | number, double |   | . | lastQty | none | number, int32 |   | . | lastPx | none | number, double |   | . | rejectReason | none | string enum, \"AccountClosed\" \"AdvancedTrailingStopUnsupported\" \"AnotherCommandPending\" \"BackMonthProhibited\" \"ExecutionProviderNotConfigured\" \"ExecutionProviderUnavailable\" \"InvalidContract\" \"InvalidPrice\" \"LiquidationOnly\" \"LiquidationOnlyBeforeExpiration\" \"MaxOrderQtyIsNotSpecified\" \"MaxOrderQtyLimitReached\" \"MaxPosLimitMisconfigured\" \"MaxPosLimitReached\" \"MaxTotalPosLimitReached\" \"MultipleAccountPlanRequired\" \"NoQuote\" \"NotEnoughLiquidity\" \"OtherExecutionRelated\" \"ParentRejected\" \"RiskCheckTimeout\" \"SessionClosed\" \"Success\" \"TooLate\" \"TradingLocked\" \"TrailingStopNonOrderQtyModify\" \"Unauthorized\" \"UnknownReason\" \"Unsupported\" |   | . | text | none | string &lt;= 8192 chars |   | . | exchangeOrderId | none | string &lt;= 64 chars |   | . ",
    "url": "/entity-system/entity-index/executionreport",
    
    "relUrl": "/entity-system/entity-index/executionreport"
  },"71": {
    "doc": "Fill",
    "title": "Fill",
    "content": "An entity that represents the Fill of an Order. Related . | Order | FillPair | . Definition . | Property | Tags | Type | Remarks | . | id | none | number, int64 |   | . | orderId | required | number, int64 | ID of the related Order entity. | . | contractId | required | number, int64 | ID of the related Contract entity. | . | timestamp | required | Date string | Time that the fill was created. | . | tradeDate | required | TradeDate | The date of the trading session that this fill occurred. | . | action | required | \"Buy\" \"Sell\" |   | . | qty | required | number, int32 | The number of contracts filled. | . | price | required | number, double | Price at which the order was filled. | . | active | required | boolean |   | . | finallyPaired | required | number, int32 |   | . ",
    "url": "/entity-system/entity-index/fill",
    
    "relUrl": "/entity-system/entity-index/fill"
  },"72": {
    "doc": "FillFee",
    "title": "FillFee",
    "content": "Related . | Fill | FillPair | Order | . Definition . | Property | Tags | Type | Remarks | . | id | none | number, int64 |   | . | clearingFee | label | number, double |   | . | clearingCurrencyId | label | number, int64 |   | . | exchangeFee | label | number, double |   | . | exchangeCurrencyId | label | number, int64 |   | . | nfaFee | label | number, double |   | . | nfaCurrencyId | label | number, int64 |   | . | brokerageFee | label | number, double |   | . | brokerageCurrencyId | label | number, int64 |   | . | ipFee | label | number, double |   | . | ipCurrencyId | label | number, int64 |   | . | commissionFee | label | number, double |   | . | commissionCurrencyId | label | number, int64 |   | . | orderRoutingFee | label | number, double |   | . | orderRoutingCurrencyId | label | number, int64 |   | . ",
    "url": "/entity-system/entity-index/fillfee",
    
    "relUrl": "/entity-system/entity-index/fillfee"
  },"73": {
    "doc": "FillPair",
    "title": "FillPair",
    "content": "An entity that represents the pair of Fills that opened and ultimately close an Order. Related . | Fill | Order | . Definition . | Property | Tags | Type | Remarks | . | id | none | number, int64 |   | . | positionId | required | number, int64 | ID of the related Position entity | . | buyFillId | required | number, int64 | ID of the related Order entity that had the \"Buy\" action. | . | sellFillId | required | number, int64 | ID of the related Order entity that had the \"Sell\" action. | . | qty | required | number, int32 | The quantity of contracts opened and closed by this FillPair. | . | buyPrice | required | number, double | Price of the Order with the \"Buy\" action. | . | sellPrice | required | number, double | Price of the Order with the \"Sell\" action. | . | active | required | boolean |   | . ",
    "url": "/entity-system/entity-index/fillpair",
    
    "relUrl": "/entity-system/entity-index/fillpair"
  },"74": {
    "doc": "/find",
    "title": "/{entity}/find",
    "content": "This operation is used to look up an entity that has a name field. Note that this operation will only work for entities with a name field. For example, /position/find is technically a valid operation but it will never return anything because Position entities do not have a name field. ",
    "url": "/all-ops/shared/find#entityfind",
    
    "relUrl": "/all-ops/shared/find#entityfind"
  },"75": {
    "doc": "/find",
    "title": "Format",
    "content": "For HTTP requests, we can use this format: . https://live.tradovateapi.com/v1/{entity}/find?name={entity_name} OR https://demo.tradovateapi.com/v1/{entity}/find?name={entity_name} . And for WebSocket requests: . &lt;entity&gt;/find &lt;msg_id&gt; name=&lt;entity_name&gt; . Example Usage: . async function entityFind(entityType, name) { const URL = `https://demo.tradovateapi.com/v1/${entityType}/find?name=${name}` let response, data try { response = await fetch(URL) data = await response.json() } catch(err) { console.error(err) } return data } await entityFind('product', 'NQ') //=&gt; // { // \"id\": 814, // \"name\": \"NQ\", // \"currencyId\": 1, // \"productType\": \"Futures\", // \"description\": \"E-Mini NASDAQ 100\", // \"exchangeId\": 2, // \"exchangeChannelId\": 4, // \"contractGroupId\": 20, // \"riskDiscountContractGroupId\": 1, // \"status\": \"Verified\", // \"months\": \"HMUZ\", // \"valuePerPoint\": 20, // \"priceFormatType\": \"Decimal\", // \"priceFormat\": -2, // \"tickSize\": 0.25, // \"allowProviderContractInfo\": false, // \"isMicro\": false, // \"marketDataSource\": \"Auto\", // \"lookupWeight\": 64, // \"hasReplay\": true // } . ",
    "url": "/all-ops/shared/find#format",
    
    "relUrl": "/all-ops/shared/find#format"
  },"76": {
    "doc": "/find",
    "title": "/find",
    "content": " ",
    "url": "/all-ops/shared/find",
    
    "relUrl": "/all-ops/shared/find"
  },"77": {
    "doc": "/fundTransaction/adjustCash",
    "title": "/fundTransaction/adjustCash",
    "content": "Called via WebSocket. Unlike the [`/cashbalance/changeDemoBalance`](/all-ops/cashbalance/changedemobalance) endpoint, this call should also move the TMD level of an account. ",
    "url": "/all-ops/fundtransaction/adjustcash#fundtransactionadjustcash",
    
    "relUrl": "/all-ops/fundtransaction/adjustcash#fundtransactionadjustcash"
  },"78": {
    "doc": "/fundTransaction/adjustCash",
    "title": "/fundTransaction/adjustCash",
    "content": " ",
    "url": "/all-ops/fundtransaction/adjustcash",
    
    "relUrl": "/all-ops/fundtransaction/adjustcash"
  },"79": {
    "doc": "/account/getCashBalanceSnapshot",
    "title": "/cashBalance/getcashbalancesnapshot",
    "content": "Get a snapshot of an Account’s cashbalance. This call is best suited for one-shot requests to display some instant data, but not for developing a real-time stream. ",
    "url": "/all-ops/cashbalance/getcashbalancesnapshot#cashbalancegetcashbalancesnapshot",
    
    "relUrl": "/all-ops/cashbalance/getcashbalancesnapshot#cashbalancegetcashbalancesnapshot"
  },"80": {
    "doc": "/account/getCashBalanceSnapshot",
    "title": "/account/getCashBalanceSnapshot",
    "content": " ",
    "url": "/all-ops/cashbalance/getcashbalancesnapshot",
    
    "relUrl": "/all-ops/cashbalance/getcashbalancesnapshot"
  },"81": {
    "doc": "/contract/getProductFeeParams",
    "title": "/contract/getProductFeeParams",
    "content": " ",
    "url": "/all-ops/contract/getproductfeeparams",
    
    "relUrl": "/all-ops/contract/getproductfeeparams"
  },"82": {
    "doc": "Getting Started",
    "title": "Getting Started",
    "content": "So, you’ve made the plunge into the Tradovate API - don’t worry, we’re here to help! This site is Tradovate’s official API Education center. Here, you’ll learn all the skills you need to begin creating applications that utilize the Tradovate API. Use what you learn to create utility applications for trading, automate a trading strategy, or even create a large scale, multi-user application. If you can dream it, you can build it. ",
    "url": "/getting-started#getting-started",
    
    "relUrl": "/getting-started#getting-started"
  },"83": {
    "doc": "Getting Started",
    "title": "Prerequisites",
    "content": "In order to access the Tradovate API, you’ll need to subscribe to API Access and create an API Key. Once you’ve created your first API Key, you’ll be able to utilize all of the features in this guide. Follow the link below to learn how to access the Tradovate API today. Learn How to Access the API B2B Partners . ",
    "url": "/getting-started#prerequisites",
    
    "relUrl": "/getting-started#prerequisites"
  },"84": {
    "doc": "Getting Started",
    "title": "Using Interactive Features",
    "content": "Take a look at the top of the page - see the . icon? Any time that you have a valid Access Token, you can click this icon and paste the token’s string value into the form that appears. If the token was valid, you’ll notice the lock icon changes to a “closed” state. Once in this state, you can use any of the REST API Try It boxes located on the right bar of the site (or by clicking the ▶ button on mobile). Add custom JSON bodies to the requests and test them right here with zero overhead! . ",
    "url": "/getting-started#using-interactive-features",
    
    "relUrl": "/getting-started#using-interactive-features"
  },"85": {
    "doc": "Getting Started",
    "title": "WebSocket Playground",
    "content": "We also offer a playground for our WebSocket APIs. Simply select a URL and click Connect. Once you receive the o open frame, you can use the Command Palette to parameterize an authorize message. When the socket has been successfully authorized, its connection is good until cancelled and you can use the Command Palette options to parameterize and generate most message types. Visit WebSocket Playground WebSocket Guide . Resources Architecture Overview . ",
    "url": "/getting-started#websocket-playground",
    
    "relUrl": "/getting-started#websocket-playground"
  },"86": {
    "doc": "Getting Started",
    "title": "Getting Started",
    "content": " ",
    "url": "/getting-started",
    
    "relUrl": "/getting-started"
  },"87": {
    "doc": "Heartbeats",
    "title": "Client Heartbeats",
    "content": "Even WebSockets have built-in pings. As mentioned in the Message Protocol section, a client is responsible to send heartbeats every 2.5 seconds to avoid closing by server due to inactivity. A heartbeat should be a frame with \"[]\" (empty array) as its text, which you can send using the WebSocket.send method. It is best to adopt a mechanism that doesn’t rely on setInterval when developing for web - this function can be throttled by the browser leading to disconnection when running in a background tab. Instead generate a timestamp (new Date().getTime() will do) with each received message. Check that against the timestamp of the last message received, and if the time has exceeded 2500ms send a heartbeat frame. Note: A server that is actively streaming live data (such as a market data subscription) will not send heartbeats while outputting messages. So long as the developer ensures that the client sends heartbeats every 2.5 seconds, the connection will stay alive. Here is an example of how to check a heartbeat without relying on setInterval or setTimeout that would be suitable for a browser. let lastTime; function checkHeartbeat(ws, verbose = false) { //on first run, lastTime is undefined if(!lastTime) { lastTime = new Date().getTime(); } const now = new Date().getTime(); if(now - lastTime &gt;= 2500) { if(verbose) { console.log('[]'); } ws.send('[]'); lastTime = now; } } . Message Protocol Heartbeats . ",
    "url": "/wss-guide/heartbeats#client-heartbeats",
    
    "relUrl": "/wss-guide/heartbeats#client-heartbeats"
  },"88": {
    "doc": "Heartbeats",
    "title": "Heartbeats",
    "content": " ",
    "url": "/wss-guide/heartbeats",
    
    "relUrl": "/wss-guide/heartbeats"
  },"89": {
    "doc": "Tradovate API",
    "title": "Welcome to the Tradovate API",
    "content": " ",
    "url": "/#welcome-to-the-tradovate-api",
    
    "relUrl": "/#welcome-to-the-tradovate-api"
  },"90": {
    "doc": "Tradovate API",
    "title": "Opening Doors to Futures Trading on the Web",
    "content": ". From automating a strategy to building an enterprise application, the Tradovate Web APIs offer everything that you’ll need to start building something special. Get Started Now . Download the OpenAPI Spec . Available as JSON or YAML. JSON YAML . ",
    "url": "/#opening-doors-to-futures-trading-on-the-web",
    
    "relUrl": "/#opening-doors-to-futures-trading-on-the-web"
  },"91": {
    "doc": "Tradovate API",
    "title": "Tradovate API",
    "content": " ",
    "url": "/",
    
    "relUrl": "/"
  },"92": {
    "doc": "How is the Tradovate API Partitioned",
    "title": "How is the Tradovate API Partitioned?",
    "content": "A major concept of the API is partitioned functionality. Each base URL represents a different part of the API’s set of features. There are two main paths that we can use the API by: . | The Tradovate REST API | The Tradovate WebSocket API | . Rest API . The REST API is a classic web API. The client makes HTTP requests to the appropriate URL endpoint, and if the request was formatted correctly it will succeed, possibly returning some relevant data back to the client. Here are the base URLs associated with the REST API: . https://demo.tradovateapi.com/v1 https://live.tradovateapi.com/v1 . The difference between these base URLs is which environment the endpoints you call will run in. The demo environment runs in simulation mode - this is a demo account; it uses fake money, but the market data is real - whereas the live environment uses your real, funded account for making trades. A developer could run his or her tests through simulation mode as long as he or she wants to, allowing a smooth transition to a funded account. WebSocket API . The WebSocket API is a set of WebSocket-based services that a client may connect to in order to receive real-time data in an event-driven manner. Typically the connected client sends messages via the WebSocket to start or stop real-time subscriptions. However, the WebSocket servers are also designed to mimic the REST API, so a client could send whatever requests are appropriate for the type of WebSocket configured. Note: to use the WebSocket API you still need to be authenticated and retrieve an Access Token using the REST API - these domains are not alternatives to one another, just different features. The WebSocket API itself covers three separate domains: . | The standard Real-Time API. This is mainly for listening to the real-time user synchronization subscription (user/syncRequest). This is located at the URL wss://demo.tradovateapi.com/v1/websocket or wss://live.tradovateapi.com/v1/websocket for simulation or live functionality, respectively. | The Market Data API. This is located at wss://md.tradovateapi.com/v1/websocket. You can subscribe to real-time quotes, DOMs, charts, and histogram data from this type of socket. | The Market Replay API. This is located at wss://replay.tradovateapi.com/v1/websocket. A Market Replay socket allows a client to subscribe to a certain timeframe and ‘replay’ that timeframe. This is not just historical chart data, but all of the DOM and market data for this time period, as well as an interactive session that a client can trade in as if it were live. | . ",
    "url": "/api-faq/how-is-the-tradovate-api-partitioned#how-is-the-tradovate-api-partitioned",
    
    "relUrl": "/api-faq/how-is-the-tradovate-api-partitioned#how-is-the-tradovate-api-partitioned"
  },"93": {
    "doc": "How is the Tradovate API Partitioned",
    "title": "How is the Tradovate API Partitioned",
    "content": " ",
    "url": "/api-faq/how-is-the-tradovate-api-partitioned",
    
    "relUrl": "/api-faq/how-is-the-tradovate-api-partitioned"
  },"94": {
    "doc": "How to Handle Data Size Limits",
    "title": "How to Handle Data Size Limits",
    "content": "The Tradovate API imposes flexible data size limits per request. There is no ‘hard-cap’ on data batch size; what may be the limit one day can change on another day. To get more than the maximum batched amount of data per request, you’ll simply have to make more requests. Imagine this scenario: . | A client wants to gather 1-minute chart data over the last 3 years. | The client authenticates their application, and then authorizes a WebSocket connection to the Market Data URL. | The client attempts a md/getChart request to retrieve data from dates three years apart, however only the last several months of data arrives. This is because the maximum amount of data transmitted by the response has been reached. | . In order to get more data than the maximum amount per request, we must make several requests and track their timestamps to get the complete set of data. Assuming the client is running a WebSocket connected to the Market Data URL, we could solve the problem described above by doing the following: . | However your application catches messages from the WebSocket server, you will need to make sure you add a condition to account for the end-of-history object. It looks like this if you parse it to a JS native object: | . { id: 123456789 //the realtimeId of the getChart subscription eoh: true } . | You’ll also need to keep track of the data you’ve gathered so far. It’s probably a good idea to keep all of the chart.bars array data. | When you receive the end-of-history object, you will need to look at the gathered bars and sort them by timestamp. You need to find the oldest bar, and start a new subscription using its timestamp as the closestTimestamp field in md/getChart’s body. | . { closestTimestamp: oldestBar.timestamp, asFarAsTimestamp: targetDate //in our example, 3 years ago } . | Wait for the next end-of-history object. If the oldest bar’s timestamp is equal to the target date, break out of the loop or resolve the chain of promises with the gathered data. Otherwise repeat the above steps until the oldest bar is your target date. | . Also see the large-chart-request project for an example of how to request large data sets in JavaScript. ",
    "url": "/api-faq/how-to-handle-data-size-limits",
    
    "relUrl": "/api-faq/how-to-handle-data-size-limits"
  },"95": {
    "doc": "How to Handle Request Size Limits",
    "title": "How to Handle Request Limits",
    "content": "It’s likely that at some point, despite your best efforts, you’ll get a time penalty response during the course of writing programs that utilize the Tradovate API. This is perfectly OK, is an intentional response, and can be handled fairly easily. Here is a scenario: . | Your program sends a request to modify a working order’s price based on a condition. By some market movement the programmer may not have accounted for, this condition becomes triggered many times within just a few seconds. | Instead of the typical response, you receive a response with the p-ticket and p-time fields. The server has determined that a threshold has been reached and issues the time penalty response. | . Note: If you receive an object with a p-captcha field, this means a third party application cannot complete the request and clients should be directed to try again in an hour. To handle the above scenario, we simply need to use the p-time field to determine the time in seconds before we can make a request again. When we retry the request we should include p-ticket as an additional field in the request body (including the original body fields). const URL = `https://demo.tradovateapi.com/v1` //we can simulate too many requests by putting them in a loop const simulatePenalty = async () =&gt; { let penaltyResponse, okResponse //this would be a really bad idea in a non-demo scenario! for(let i = 0; i &lt; 100; i++) { penaltyResponse = await fetch(URL + `/order/placeOrder`, { accountSpec: yourUserName, accountId: yourAcctId, action: \"Buy\", symbol: \"MYMM1\", orderQty: 1, orderType: \"Market\", isAutomated: true }) if(penaltyResponse[\"p-ticket\"]) { break //exit loop on penalty response received } } const pTime = penaltyResponse[\"p-time\"], pTicket = penaltyResponse[\"p-ticket\"], pCaptcha = penaltyResponse[\"p-captcha\"] if(pCaptcha) { console.error(\"Captcha required. Please try again in 1 hour.\") return } console.log(`Trying again in ${pTime} seconds...`) const timeout = setTimeout(() =&gt; { okResponse = await fetch(URL + `/order/placeOrder`, { accountSpec: yourUserName, accountId: yourAcctId, action: \"Buy\", symbol: \"MYMM1\", orderQty: 1, orderType: \"Market\", isAutomated: true, \"p-ticket\": pTicket }) }, 1000 * pTime) console.log(okResponse) } simulatePenalty() . ",
    "url": "/api-faq/how-to-handle-request-size-limits#how-to-handle-request-limits",
    
    "relUrl": "/api-faq/how-to-handle-request-size-limits#how-to-handle-request-limits"
  },"96": {
    "doc": "How to Handle Request Size Limits",
    "title": "How to Handle Request Size Limits",
    "content": " ",
    "url": "/api-faq/how-to-handle-request-size-limits",
    
    "relUrl": "/api-faq/how-to-handle-request-size-limits"
  },"97": {
    "doc": "WebSocket Guide",
    "title": "WebSocket Guide",
    "content": " ",
    "url": "/wss-guide/",
    
    "relUrl": "/wss-guide/"
  },"98": {
    "doc": "WebSocket Guide",
    "title": "Introduction",
    "content": "You’ll need to create a WebSocket instance using one of the real-time API URL’s. However, instead of using the https:// prefix we will use the wss:// WebSocket protocol prefix. Here’s an example using our demo API URL: . wss://demo.tradovateapi.com/v1/websocket . WebSockets are supported in all browsers, natively, and in many other contexts such as NodeJS. Instantiating and connecting a new WebSocket is as simple as this: . const mySocket = new WebSocket('wss://demo.tradovateapi.com/v1/websocket'); . Of course, this socket is not authorized and cannot complete any calls yet. You can see how to perform this procedure on the Authorization Procedure page. For those who like to learn by doing, see our WebSocket Playground. Resources Message Protocol . ",
    "url": "/wss-guide/#introduction",
    
    "relUrl": "/wss-guide/#introduction"
  },"99": {
    "doc": "API FAQ",
    "title": "API Frequently Asked Questions",
    "content": "In this section you will find common questions about API use and workflows. ",
    "url": "/api-faq#api-frequently-asked-questions",
    
    "relUrl": "/api-faq#api-frequently-asked-questions"
  },"100": {
    "doc": "API FAQ",
    "title": "API FAQ",
    "content": " ",
    "url": "/api-faq",
    
    "relUrl": "/api-faq"
  },"101": {
    "doc": "Realtime Market Data",
    "title": "Market Data",
    "content": "The most interesting benefit of using the WebSocket client is getting access to data in real-time. This service is available by connecting a WebSocket to wss://md.tradovateapi.com/v1/websocket. ",
    "url": "/wss-guide/market-data#market-data",
    
    "relUrl": "/wss-guide/market-data#market-data"
  },"102": {
    "doc": "Realtime Market Data",
    "title": "Accessing Market Data",
    "content": "The Tradovate Market Data API provides a way to access market data such as quotes, DOM, charts and histograms. The API uses JSON format for request bodies and response data. The exchange of requests and responses are transmitted via the Tradovate WebSocket protocol. Typical usage of the Market Data API consists of the following steps: . 1. Acquire An Access Token Using Credentials . Client uses the standard Access procedure to acquire an Access Token. 2. Open a WebSocket and Get Authorized . Client opens a WebSocket connection and sends their access token using the authorization procedure noted in the WebSockets section. 3. Build a Request . Request parameters are an object in JSON format. Each request for real-time data requires a symbol parameter that specifies the contract for which market data is requested. Contract can be specified either by the contract symbol string or by the contract ID integer: . { \"symbol\":\"ESM7\" // Contract is specified by contract symbol (contract.name) ... } // or { \"symbol\":123456 // Contract is specified by contract ID (contract.id) ... } . Requests may have additional parameters, which are described in the corresponding sections. ",
    "url": "/wss-guide/market-data#accessing-market-data",
    
    "relUrl": "/wss-guide/market-data#accessing-market-data"
  },"103": {
    "doc": "Realtime Market Data",
    "title": "Notes",
    "content": ". | In order to utilize market data via API, you must first become a registered subvendor of CME Market Data. | A Market Data Socket follows the same protocols and authorization procedure as a Live/Demo realtime user data socket. | . ",
    "url": "/wss-guide/market-data#notes",
    
    "relUrl": "/wss-guide/market-data#notes"
  },"104": {
    "doc": "Realtime Market Data",
    "title": "Realtime Market Data",
    "content": ". | Market Data . | Accessing Market Data . | 1. Acquire An Access Token Using Credentials | 2. Open a WebSocket and Get Authorized | 3. Build a Request | . | Notes | . | . ",
    "url": "/wss-guide/market-data",
    
    "relUrl": "/wss-guide/market-data"
  },"105": {
    "doc": "replay/initializeClock",
    "title": "replay/initializeClock",
    "content": ". | This operation starts the replay session and should be called right away after the socket is authorized. | The operation is only valid when using a Market Replay Socket (a WebSocket connected to the Market Replay URL, wss://replay.tradovateapi.com/v1/websocket) | . Example . const myReplaySocket = new WebSocket('wss://replay.tradovateapi.com/v1/websocket'); let msg_i = 0; //... //perform the auth procedure. See the WebSockets Authorization Procedure for more details //... const body = { startTimestamp: new Date('01/01/2024'), speed: 400, initialBalance: 50000 }; myReplaySocket.send(`replay/initializeClock\\n${++msg_i}\\n\\n${JSON.stringify(body)}`); . Fields . | Property | Tags | Type | Remarks | . | startTimestamp | required | Date string |   | . | speed | required | number (0-400) | Represents the percent speed of real-time that the replay market progresses. | . | initialBalance | required | number | The balance that the generated replay account is initialized with. | . ",
    "url": "/wss-guide/market-replay/initialize-clock",
    
    "relUrl": "/wss-guide/market-replay/initialize-clock"
  },"106": {
    "doc": "/orderStrategy/interruptOrderStrategy",
    "title": "/orderStrategy/interruptOrderStrategy",
    "content": " ",
    "url": "/all-ops/orderstrategy/interruptorderstrategy",
    
    "relUrl": "/all-ops/orderstrategy/interruptorderstrategy"
  },"107": {
    "doc": "/item",
    "title": "/{entity}/item",
    "content": "This operation is used to look up an entity that you already have the ID for. ",
    "url": "/all-ops/shared/item#entityitem",
    
    "relUrl": "/all-ops/shared/item#entityitem"
  },"108": {
    "doc": "/item",
    "title": "Format",
    "content": "For HTTP requests, we can use this format: . https://live.tradovateapi.com/v1/{entity}/item?id={item_id} OR https://demo.tradovateapi.com/v1/{entity}/item?id={item_id} . And for WebSocket requests: . &lt;entity&gt;/item &lt;msg_id&gt; id=&lt;entity_id&gt; . Example Usage: . async function entityItem(entityType, id) { const URL = `https://demo.tradovateapi.com/v1/${entityType}/item?id=${id}` let response, data try { response = await fetch(URL) data = await response.json() } catch(err) { console.error(err) } return data } await entityItem('contract', 2710963) //=&gt; // { // \"id\": 2710963, // \"name\": \"ESM2\", // \"contractMaturityId\": 46104, // \"status\": \"DefinitionChecked\", // \"providerTickSize\": 0.25 // } . ",
    "url": "/all-ops/shared/item#format",
    
    "relUrl": "/all-ops/shared/item#format"
  },"109": {
    "doc": "/item",
    "title": "/item",
    "content": " ",
    "url": "/all-ops/shared/item",
    
    "relUrl": "/all-ops/shared/item"
  },"110": {
    "doc": "/items",
    "title": "/{entity}/items",
    "content": "This operation is used to look up an entity that you already have the ID for. ",
    "url": "/all-ops/shared/items#entityitems",
    
    "relUrl": "/all-ops/shared/items#entityitems"
  },"111": {
    "doc": "/items",
    "title": "Format",
    "content": "For HTTP requests, we can use this format: . https://live.tradovateapi.com/v1/{entity}/items?ids={item_id_a},{item_id_b} OR https://demo.tradovateapi.com/v1/{entity}/items?ids={item_id_a},{item_id_b} . And for WebSocket requests: . &lt;entity&gt;/items &lt;msg_id&gt; ids=&lt;entity_id&gt; . Example Usage: . async function entityItems(entityType, ids) { const URL = `https://demo.tradovateapi.com/v1/${entityType}/items?ids=${ids.join(',')}` let response, data try { response = await fetch(URL) data = await response.json() } catch(err) { console.error(err) } return data } await entityItems('contract', [2710963]) //=&gt; // [ // { // \"id\": 2710963, // \"name\": \"ESM2\", // \"contractMaturityId\": 46104, // \"status\": \"DefinitionChecked\", // \"providerTickSize\": 0.25 // } // ] . ",
    "url": "/all-ops/shared/items#format",
    
    "relUrl": "/all-ops/shared/items#format"
  },"112": {
    "doc": "/items",
    "title": "/items",
    "content": " ",
    "url": "/all-ops/shared/items",
    
    "relUrl": "/all-ops/shared/items"
  },"113": {
    "doc": "/ldeps",
    "title": "/{entity}/ldeps",
    "content": "This operation is used to look up entities of this type that are dependent on other ‘master’ entities. ",
    "url": "/all-ops/shared/ldeps#entityldeps",
    
    "relUrl": "/all-ops/shared/ldeps#entityldeps"
  },"114": {
    "doc": "/ldeps",
    "title": "Format",
    "content": "For HTTP requests, we can use this format: . https://live.tradovateapi.com/v1/{entity}/ldeps?masterids={item_id_a},{item_id_b},... OR https://demo.tradovateapi.com/v1/{entity}/ldeps?masterids={item_id_a},{item_id_b},... And for WebSocket requests: . &lt;entity&gt;/deps &lt;msg_id&gt; masterids=&lt;entity_id_a&gt;,&lt;entity_id_b&gt;,... Example Usage: . async function entityLDeps(entityType, masterids) { const URL = `https://demo.tradovateapi.com/v1/${entityType}/ldeps?masterids=${masterids.join(',')}` const config = { } let response, data try { response = await fetch(URL) data = await response.json() } catch(err) { console.error(err) } return data } await entityLDeps('productMargin', [814, 799]) //=&gt; // [ // { // \"id\": 814, // \"initialMargin\": 17050, // \"maintenanceMargin\": 15500, // \"timestamp\": \"2022-04-21T00:09:12.512Z\" // }, // { // \"id\": 799, // \"initialMargin\": 12320, // \"maintenanceMargin\": 11200, // \"timestamp\": \"2022-04-21T00:09:12.511Z\" // } // ] . Notes . | masterids Entity Type | Related Entity Types | . | (The entity type that should be used for masterid parameter) | (The operation’s returned type) | . | Account | CashBalance CashBalanceLog MarginSnapshot AccountRiskStatus UserAccountAutoLiq Position Order OrderStrategy User UserAccountPositionLimit | . | Command | CommandReport ExecutionReport | . | Contract | ContractMaturity | . | Product | ProductMargin ContractMaturity ProductSession | . | Order | Command OrderVersion Fill | . | Exchange | Product | . | OrderStrategy | OrderStrategyLink | . | Fill | FillFee | . | Position | FillPair | . | User | Account TradingPermission ContactInfo | . | UserAccountPositionLimit | UserAccountRiskParameter | . ",
    "url": "/all-ops/shared/ldeps#format",
    
    "relUrl": "/all-ops/shared/ldeps#format"
  },"115": {
    "doc": "/ldeps",
    "title": "/ldeps",
    "content": " ",
    "url": "/all-ops/shared/ldeps",
    
    "relUrl": "/all-ops/shared/ldeps"
  },"116": {
    "doc": "/order/liquidatePosition",
    "title": "/order/liquidatePosition",
    "content": " ",
    "url": "/all-ops/order/liquidateposition",
    
    "relUrl": "/all-ops/order/liquidateposition"
  },"117": {
    "doc": "/list",
    "title": "/{entity}/list",
    "content": "This operation is used to look up all the entities that exist within your User’s permissions scope. ",
    "url": "/all-ops/shared/list#entitylist",
    
    "relUrl": "/all-ops/shared/list#entitylist"
  },"118": {
    "doc": "/list",
    "title": "Format",
    "content": "For HTTP requests, we can use this format: . https://live.tradovateapi.com/v1/{entity}/list OR https://demo.tradovateapi.com/v1/{entity}/list . And for WebSocket requests: . &lt;entity&gt;/list &lt;msg_id&gt; . Example Usage: . async function entityList(entityType) { const URL = `https://demo.tradovateapi.com/v1/${entityType}/list` let response, data try { response = await fetch(URL) data = await response.json() } catch(err) { console.error(err) } return data } await entityList('account') //=&gt; // [ // { // \"id\": 0, // \"name\": \"string\", // \"userId\": 0, // \"accountType\": \"Customer\", // \"active\": true, // \"clearingHouseId\": 0, // \"riskCategoryId\": 0, // \"autoLiqProfileId\": 0, // \"marginAccountType\": \"Speculator\", // \"legalStatus\": \"Individual\", // \"timestamp\": \"2019-08-24T14:15:22Z\", // \"readonly\": true // } // ] . ",
    "url": "/all-ops/shared/list#format",
    
    "relUrl": "/all-ops/shared/list#format"
  },"119": {
    "doc": "/list",
    "title": "/list",
    "content": " ",
    "url": "/all-ops/shared/list",
    
    "relUrl": "/all-ops/shared/list"
  },"120": {
    "doc": "Listen to Message Events",
    "title": "Message Events",
    "content": "WebSockets communicate asynchronously between the WebSocket Client and a WebSocket Server. When a message is received by the client, an event is raised. We can listen to these events using one of two methods. const mySocket = new WebSocket(oneOfTradovateWSSUrls) //named event hooks mySocket.onopen = _ =&gt; { /*auth procedure*/ } mySocket.onmessage = msg =&gt; {} mySocket.onclose = msg =&gt; {} //or event listener interface mySocket.addEventListener('message', msg =&gt; { //... }) . ",
    "url": "/all-ops/websockets/messages#message-events",
    
    "relUrl": "/all-ops/websockets/messages#message-events"
  },"121": {
    "doc": "Listen to Message Events",
    "title": "Decoding Messages",
    "content": "Messages come as plain strings. In order to use the data, we need to decode it first. Here’s a simple helper that you can use to decode messages you receive from a Tradovate WebSocket server. /** * Takes a raw WebSocket message and maps it to a tuple of `[frameType, data]` * @returns {[T:string, data:{e?: string, i?: number, s?: number, d?: {[k:string]:any}} | null]} */ function prepareMessage(msg) { const T = msg.data.slice(0,1) let data = msg.data.slice(1) if(data) { data = JSON.parse(data) } return [T, data] } . ",
    "url": "/all-ops/websockets/messages#decoding-messages",
    
    "relUrl": "/all-ops/websockets/messages#decoding-messages"
  },"122": {
    "doc": "Listen to Message Events",
    "title": "WebSocket as an Observable",
    "content": "You can turn your WebSockets’ events into functional data streams using the popular RXJS package. //imports if using node const WebSocket = require('ws') const { BehaviorSubject } = require('rxjs') //imports if using browser import { BehaviorSubject } from 'rxjs' /** * Class to represent an Observable WebSocket. */ class ObservableSocket { constructor() { this.socket = null this.counter = 0 //BehaviorSubject lets us push values, can stay private. this._messages = new BehaviorSubject() //Observable does not, so we want this.messages to be public this.messages = this._messages.asObservable() } send({url, query, body}) { const message = `${url}\\n${this.counter++}\\n${query || ''}\\n${body ? JSON.stringify(body) : ''}` this.socket.send(message) } connect(url, accessToken) { this.socket = new WebSocket(url) this.socket.onopen = _ =&gt; { const msg = `auth\\n${this.counter++}\\n\\n${accessToken}` } this.socket.onmessage = msg =&gt; { const [T, data] = prepareMessage(msg) this._messages.next({ type: T, data }) } } subscribe(subscriber) { return this.messages.subscribe(subscriber) } pipe(fns) { return this.messages.pipe(...fns) } } . Usage: . import { map, filter } from 'rxjs' const mySocket = new ObservableSocket() //made up implementation of accessToken call const { accessToken } = await accessTokenRequest(credentials) mySocket.connect('wss://md.tradovateapi.com/v1/websocket') //easily and functionally filter and transform the data const quotes = mySocket.pipe( filter(m =&gt; m.e &amp;&amp; m.e === 'md' &amp;&amp; m.d &amp;&amp; m.d.quotes), map(m =&gt; m.d.quotes) ) //subscribe to the quotes stream const subscription = quotes.subscribe(quote =&gt; { /* do things with quote */ }) //send the actual quote subscription request mySocket.send({ url: 'md/subscribeQuote', body: { symbol: 'ESM2' } }) . ",
    "url": "/all-ops/websockets/messages#websocket-as-an-observable",
    
    "relUrl": "/all-ops/websockets/messages#websocket-as-an-observable"
  },"123": {
    "doc": "Listen to Message Events",
    "title": "Listen to Message Events",
    "content": " ",
    "url": "/all-ops/websockets/messages",
    
    "relUrl": "/all-ops/websockets/messages"
  },"124": {
    "doc": "MarginSnapshot",
    "title": "MarginSnapshot",
    "content": "An object that represents a snapshot of a user’s Margin status. Related . | Account | CashBalanceSnapshot | ProductMargin | ContractMargin | . Definition . | Property | Tags | Type | Remarks | . | id | none | number, int64 |   | . | timestamp | required | Date string | Time that this snapshot was produced. | . | riskTimePeriodId | required | number, int64 |   | . | initialMargin | required | number, double |   | . | maintenanceMargin | required | number, double |   | . | autoLiqLevel | none | number, double |   | . | liqOnlyLevel | none | number, double |   | . | totalUsedMargin | required | number, double |   | . | fullInitialMargin | required | number, double |   | . ",
    "url": "/entity-system/entity-index/marginsnapshot",
    
    "relUrl": "/entity-system/entity-index/marginsnapshot"
  },"125": {
    "doc": "md/cancelChart",
    "title": "md/cancelChart",
    "content": " ",
    "url": "/wss-guide/market-data/cancel-chart",
    
    "relUrl": "/wss-guide/market-data/cancel-chart"
  },"126": {
    "doc": "md/getChart",
    "title": "md/getChart",
    "content": "You can use this endpoint via Market Data socket to receive bar or tick chart data. ",
    "url": "/wss-guide/market-data/getchart",
    
    "relUrl": "/wss-guide/market-data/getchart"
  },"127": {
    "doc": "md/getChart",
    "title": "Request",
    "content": "In the Tradovate WebSocket protocol, this is how you would structure your request: . md/getchart 0 {\"symbol\":\"ESZ4\",\"chartDescription\":{\"underlyingType\":\"MinuteBar\",\"elementSize\":1,\"elementSizeUnit\":\"UnderlyingUnits\",\"withHistogram\":false},\"timeRange\":{\"asMuchAsElements\":100}} . Remarks . Below is an example of all the available parameters in the request body: . { \"symbol\":\"ESM7\" | 123456, \"chartDescription\": { \"underlyingType\":\"MinuteBar\", // Available values: Tick, DailyBar, MinuteBar, Custom, DOM \"elementSize\":15, \"elementSizeUnit\":\"UnderlyingUnits\", // Available values: Volume, Range, UnderlyingUnits, Renko, MomentumRange, PointAndFigure, OFARange \"withHistogram\": true | false }, \"timeRange\": { // All fields in \"timeRange\" are optional, but at least any one is required \"closestTimestamp\":\"2017-04-13T11:33Z\", \"closestTickId\":123, \"asFarAsTimestamp\":\"2017-04-13T11:33Z\", \"asMuchAsElements\":66 }, } . You can determine what fields and values to use based on the following tables: . ChartDescription Usage . | chartDescripton Field | Type | Remarks | . | underlyingType | \"Tick\", \"DailyBar\", \"MinuteBar\", \"Custom\", \"DOM\" |   | . | elementSize | int | This is the size of a bar for the requested chart, in elementSizeUnit units. | . | elementSizeUnit | \"Volume\", \"Range\", \"UnderlyingUnits\", \"Renko\", \"MomentumRange\", \"PointAndFigure\", \"OFARange\" |   | . TimeRange Field Types . | timeRange Field | Type | Remarks | . | `` | number |   | . ",
    "url": "/wss-guide/market-data/getchart#request",
    
    "relUrl": "/wss-guide/market-data/getchart#request"
  },"128": {
    "doc": "md/getChart",
    "title": "Response",
    "content": "{ \"bars\": [ // \"bars\" may contain multiple bar objects { \"timestamp\":\"2017-04-13T11:00:00.000Z\", \"open\":2334.25, \"high\":2334.5, \"low\":2333, \"close\":2333.75, \"upVolume\":4712, \"downVolume\":201, \"upTicks\":1333, \"downTicks\":82, \"bidVolume\":2857, \"offerVolume\":2056 } ] } . ",
    "url": "/wss-guide/market-data/getchart#response",
    
    "relUrl": "/wss-guide/market-data/getchart#response"
  },"129": {
    "doc": "md/subscribeDOM",
    "title": "md/subscribeDOM",
    "content": " ",
    "url": "/wss-guide/market-data/subscribe-dom",
    
    "relUrl": "/wss-guide/market-data/subscribe-dom"
  },"130": {
    "doc": "md/subscribeHistogram",
    "title": "md/subscribeHistogram",
    "content": " ",
    "url": "/wss-guide/market-data/subscribe-histogram",
    
    "relUrl": "/wss-guide/market-data/subscribe-histogram"
  },"131": {
    "doc": "md/subscribeQuote",
    "title": "md/subscribeQuote",
    "content": " ",
    "url": "/wss-guide/market-data/subscribe-quote",
    
    "relUrl": "/wss-guide/market-data/subscribe-quote"
  },"132": {
    "doc": "md/unsubscribeDOM",
    "title": "md/unsubscribeDOM",
    "content": " ",
    "url": "/wss-guide/market-data/unsubscribe-dom",
    
    "relUrl": "/wss-guide/market-data/unsubscribe-dom"
  },"133": {
    "doc": "md/unsubscribeHistogram",
    "title": "md/unsubscribeHistogram",
    "content": " ",
    "url": "/wss-guide/market-data/unsubscribe-histogram",
    
    "relUrl": "/wss-guide/market-data/unsubscribe-histogram"
  },"134": {
    "doc": "md/unsubscribeQuote",
    "title": "md/unsubscribeQuote",
    "content": " ",
    "url": "/wss-guide/market-data/unsubscribe-quote",
    
    "relUrl": "/wss-guide/market-data/unsubscribe-quote"
  },"135": {
    "doc": "/auth/me",
    "title": "/auth/me",
    "content": " ",
    "url": "/all-ops/auth/me",
    
    "relUrl": "/all-ops/auth/me"
  },"136": {
    "doc": "Message Protocol",
    "title": "Server Frames",
    "content": "The WebSocket server communicates in frames. A frame consists of two parts - a ‘type’ prefix character and an array of JSON data. These two parts are concatenated into a string, and we will be responsible for creating the logic to deconstruct such messages on the client. The following are the message types supported and sent by the Tradovate WebSocket: . | 'o': Open frame. Every time a new session is established, the server must immediately send the open frame. This is required, as some protocols (mostly polling) can’t distinguish between a properly established connection and a broken one - we must convince the client that it is indeed a valid URL and it can be expecting further messages in the future via that URL. | 'h': Heartbeat frame. Most loadbalancers have arbitrary timeouts on connections. In order to keep connections from breaking, the server must send a heartbeat frame every now and then. The server sends a heartbeat about every 2.5 seconds, and to keep the connection alive the client must also send a response beat in the form of an empty array, stringified ('[]') . | 'a': A string containing an Array of JSON-encoded messages. For example: 'a[{\"data\": \"value\"}]'. | 'c': Close frame. This frame is send to the browser every time the client asks for data on closed connection. This may happen multiple times. Close frame contains a code and a string explaining a reason of closure, like: c[3000, \"Go away!\"]. | . ",
    "url": "/wss-guide/message-protocol#server-frames",
    
    "relUrl": "/wss-guide/message-protocol#server-frames"
  },"137": {
    "doc": "Message Protocol",
    "title": "Decoding Server Frames",
    "content": "Tradovate uses ‘a’ frames as a backbone for its own message protocol. Below are a few bits of example data. a[{\"s\":200,\"i\":23,\"d\":{\"id\":65543,\"name\":\"CLZ6\",\"contractMaturityId\":6727}}] a[{\"e\":\"props\",\"d\":{\"entityType\":\"order\",\"eventType\":\"Created\",\"entity\":{\"id\":210518,\"accountId\":25,\"contractId\":560901,\"timestamp\":\"2016-11-04T00:02:36.626Z\",\"action\":\"Sell\",\"ordStatus\":\"PendingNew\",\"admin\":false}}}] . You can quickly parse frames into more consumable data using a function such as the decodeMessage example below. It will turn the string message into a tuple that you can destructure. function decodeMessage(msg) { const T = msg.data.slice(0, 1); let payload = null; const data = msg.data.slice(1); if(data) { payload = JSON.parse(data); } return [T, payload]; } //usage: mySocket.onmessage = msg =&gt; { //data may be null const [T, data] = decodeMessage(msg); switch(T) { case 'a': { //react to data break; } } } . ",
    "url": "/wss-guide/message-protocol#decoding-server-frames",
    
    "relUrl": "/wss-guide/message-protocol#decoding-server-frames"
  },"138": {
    "doc": "Message Protocol",
    "title": "Message Types",
    "content": "There are a variety of message types that can be sent by the WebSocket. The message types can be sorted into two overarching message categories - Server Events and Client Responses. ",
    "url": "/wss-guide/message-protocol#message-types",
    
    "relUrl": "/wss-guide/message-protocol#message-types"
  },"139": {
    "doc": "Message Protocol",
    "title": "Server Event Message",
    "content": "A Server Event Message is sent from the server, not regarding an outgoing request initiated by the client. These messages come in a few varieties. In each response object, the \"e\" field specifies the server event type: . \"props\" Server Event . { \"e\":\"props\", \"d\":{ \"entityType\":\"order\", \"eventType\":\"Created\", \"entity\":{ \"id\":210518, \"accountId\":25, \"contractId\":560901, \"timestamp\":\"2016-11-04T00:02:36.626Z\", \"action\":\"Sell\", \"ordStatus\":\"PendingNew\", \"admin\":false } } } . This is a notification that an entity was created, updated or deleted. The \"d\" field specifies details of the event. Each \"props\" type event will have the following fields: . | \"entityType\" - defines the type of the entity that triggered the event. | \"entity\" - The actual entity object as JSON. For more details on the structure of various entity objects, explore the Enitities Index pages. | \"eventType\" - \"Created\", \"Updated\" or \"Deleted\". Represents the action that ocurred with this entity as the target. | . \"shutdown\" Server Event . { \"e\":\"shutdown\", \"d\":{ \"reasonCode\": \"Maintenance\" | \"ConnectionQuotaReached\" | \"IPQuotaReached\", \"reason\": string //may not always be present } } . A notification before graceful shutdown of the socket connection. The \"d\" field specifies details: . | \"reasonCode\" field with options “Maintenance”, “ConnectionQuotaReached”, “IPQuotaReached” | \"reason\" field is optional and may contain a readable explanation | . \"md\" Server Event (Market Data) . { \"e\":\"md\", \"d\": { \"quotes\": [ { \"timestamp\":\"2021-04-13T04:59:06.588Z\", \"contractId\":123456, \"entries\": { \"Bid\": { \"price\":18405.123, \"size\":7.123 }, \"TotalTradeVolume\": { \"size\":4118.123 }, \"Offer\": { \"price\":18410.012, \"size\":12.35 }, \"LowPrice\": { \"price\":18355.23 }, \"Trade\": { \"price\":18405.023, \"size\":2.10 }, \"OpenInterest\": { \"size\":40702.024 }, \"OpeningPrice\": { \"price\":18515.123 }, \"HighPrice\": { \"price\":18520.125 }, \"SettlementPrice\": { \"price\":18520.257 } } } ] } } . These notifications are used by market data feed services only. Market Data is an advance API feature that requires CME Market Data Subvendor status in order to use. See the Market Data section for more details. \"clock\" Server Event (Replay) . { \"e\": \"clock\", //the \"d\" field is JSON, you must decode it. \"d\": \"{\\\"t\\\":\\\"2019-08-26T16:43:08.599Z\\\",\\\"s\\\":20}\" } . Market Replay clock synchronization message. See the Market Replay section for more details. ",
    "url": "/wss-guide/message-protocol#server-event-message",
    
    "relUrl": "/wss-guide/message-protocol#server-event-message"
  },"140": {
    "doc": "Message Protocol",
    "title": "Client Response Message",
    "content": "A Client Response Message is issued when a client makes a request. These messages are intended to mimic REST API responses and have the following structure: . { \"i\":26, \"s\":200, \"d\":{ \"id\":478866, \"name\":\"6EZ6\", \"contractMaturityId\":23574 } } . | \"i\" field is a id of corresponding client request (see “Client requests” below). A responses id will always match the id of the request that generated it. | \"s\" field is a HTTP status code of response | \"d\" field is a content of response. If HTTP status is 2xx, this field contains JSON response as defined in Swagger specification of the corresponding request. Otherwise, \"d\" is a string representation of error text. | . ",
    "url": "/wss-guide/message-protocol#client-response-message",
    
    "relUrl": "/wss-guide/message-protocol#client-response-message"
  },"141": {
    "doc": "Message Protocol",
    "title": "Client Requests",
    "content": "We use standard text documents for our client request protocol, with lines delimited by \\n newline characters. Each document sent by the client contains exactly one request. The frame consists of four fields: . | An endpoint name as defined in the spec. These are any of the endpoints that you could request from the standard REST API. | A unique integer ID of the request. The ID should be unique in the scope of the current connection. This ID will be used as a reference by the server in the response messages (see “Response Message” above) | an optional field with parameters identical to query parameters of REST API | an optional field that is identical to a body parameter of REST API | . The four fields must be separated by the '\\n' (“new line”) character. This is how message parameters are delimited when they get decoded. Request Examples . An example of a request without query or body: . executionReport/list 4 . An example of a request with a query parameter: . tradingPermission/ldeps 8 masterids=1 . An example of a request with a body: . contract/rollcontract 33 {\"name\":\"YMZ6\",\"forward\":true,\"ifExpired\":true} . Introduction Heartbeats . ",
    "url": "/wss-guide/message-protocol#client-requests",
    
    "relUrl": "/wss-guide/message-protocol#client-requests"
  },"142": {
    "doc": "Message Protocol",
    "title": "Message Protocol",
    "content": " ",
    "url": "/wss-guide/message-protocol",
    
    "relUrl": "/wss-guide/message-protocol"
  },"143": {
    "doc": "/order/modifyOrder",
    "title": "/order/modifyOrder",
    "content": " ",
    "url": "/all-ops/order/modifyorder",
    
    "relUrl": "/all-ops/order/modifyorder"
  },"144": {
    "doc": "/orderStrategy/modifyOrderStrategy",
    "title": "/orderStrategy/modifyOrderStrategy",
    "content": " ",
    "url": "/all-ops/orderstrategy/modifyorderstrategy",
    
    "relUrl": "/all-ops/orderstrategy/modifyorderstrategy"
  },"145": {
    "doc": "/auth/oAuthToken",
    "title": "Using OAuth for Your Tradovate Application’s Authentication",
    "content": "In this short tutorial, we will cover using the OAuth service to authenticate users for your application. Authenticating your application via OAuth for Tradovate is a three step process. | We navigate to a special OAuth URL using our client id and client secret, which will be supplied by Tradovate. We present our Tradovate credentials here. | After presenting our credentials, we will be redirected to a supplied redirect URL, but a single-use code will be in the URL query. Our server must extract the code from the query so we can use it in step 3. | We exchange the extracted code for our access token, and we are officially an authenticated entity. | . ",
    "url": "/all-ops/auth/oauthtoken#using-oauth-for-your-tradovate-applications-authentication",
    
    "relUrl": "/all-ops/auth/oauthtoken#using-oauth-for-your-tradovate-applications-authentication"
  },"146": {
    "doc": "/auth/oAuthToken",
    "title": "Getting Setup",
    "content": "We will be starting this project from scratch, however the complete solution is also provided in this repo so feel free to run it. If you’re following along from scratch, boot up a command terminal and navigate to a directory of your choosing. Run the following commands: . mkdir oauth-example cd oauth-example yarn init . Follow the prompts after init. There’s nothing wrong with simply using the defaults. We will need some utilities to help us complete this project. Let’s add those as well: . yarn add dotenv express express-session node-cache request request-promise-native . This seems like a lot, but it’s actually quite bare-bones. | dotenv allows us to store some variables locally. I’ll be using it to show how to hide our client secret. | express and express-session are mainstream server-components. Express gives our server typical routing capabilities. express-session allows us to use user-specific session data in our express routes. | node-cache is a simple stand-in for a database (for our dev purposes, in reality use a database). | Finally request and request-promise-native allow us to send requests from the backend asynchronously like we would on the front end. | . Now that our dependencies are in order, let’s add our environment variables file. Create a new file called .env. CLIENT_ID=1 CLIENT_SECRET='your_client_secret' . Replace the values with your special client variables, provided to you by Tradovate. Next we’ll add our index.js file: . //index.js require('dotenv').config() const express = require('express') const request = require('request-promise-native') const NodeCache = require('node-cache') const session = require('express-session') const app = express() const PORT = 3030 //this is a replacement for a database in this example. //Use a database or some storage solution in a real world app. const all_tokens = new NodeCache({ deleteOnExpire: true }) //in order to use process.env, we must also create a .env file. //This is not included in the example code for security reasons. //See the tutorial for details on how to format the variables in the .env file. const CLIENT_ID = process.env.CLIENT_ID const CLIENT_SECRET = process.env.CLIENT_SECRET const REDIRECT_URI = `http://localhost:3030/oauth/tradovate/callback` const EXCHANGE_URL = `https://live.tradovateapi.com/auth/oauthtoken` const AUTH_URL = `https://trader.tradovate.com/oauth` // ROUTES --------------------------------------------------------------------- app.get('/', (req, res) =&gt; { res.setHeader('Content-Type', 'text/html') res.write(`&lt;h2&gt;Tradovate OAuth&lt;/h2&gt;`) res.end() }) // ENTRY ---------------------------------------------------------------------- app.listen(PORT, () =&gt; console.log(`Starting your app on http://localhost:${PORT}`)) . We import our dependencies using the standard node require. We’ll be using port 3030 for our examples. We also initialize our node-cache database stand-in. Then we pull our data from the .env file using node’s process.env property. This allows us to obfuscate our client id and client secret - if you add .env to your .gitignore ledger, it won’t even show up on github. Now nobody can steal our credentials. In the ROUTES section, we setup a simple home route that just sends back an HTML heading with our title inside. We will use this route later to fork our login logic, but for now this will suffice. Finally, we start the app up by listening on port 3030. To run the app, we could call node index.js from the terminal. But if you’d rather call yarn start, add this script to your package.json: . { //... \"scripts\": { \"start\": \"node index.js\" }, //... } . Now we can start our app by calling yarn start. We should see ‘Starting your app on http://localhost:3030’ logged to the terminal, and navigating to localhost:3030 should yield your ‘Tradovate OAuth’ heading if it works. ",
    "url": "/all-ops/auth/oauthtoken#getting-setup",
    
    "relUrl": "/all-ops/auth/oauthtoken#getting-setup"
  },"147": {
    "doc": "/auth/oAuthToken",
    "title": "Starting the OAuth Flow",
    "content": "In order to start the OAuth flow, we must first redirect our users to a constructed OAuth link. This link needs to contain our client id and a redirect URI - the URI for our server’s OAuth callback. Let’s build our URL now: . //construct our authorization code request URL const authUrl = AUTH_URL + `?response_type=code` + `&amp;client_id=${encodeURIComponent(CLIENT_ID)}` + `&amp;redirect_uri=${encodeURIComponent(REDIRECT_URI)}` . Now we need to change our route code. Add a new route for '/auth': . app.get('/auth', (_, res) =&gt; { res.redirect(authUrl) }) . We perform a simple redirect to our constructed authUrl. Then in the '/' route: . app.get('/', (req, res) =&gt; { res.setHeader('Content-Type', 'text/html') res.write(`&lt;h2&gt;Tradovate OAuth&lt;/h2&gt;`) res.write(`&lt;a href=\"/auth\"&gt;&lt;h3&gt;Click to Authenticate&lt;/h3&gt;&lt;/a&gt;) //&lt;-- add this link res.end() }) . We’ve added an anchor element to our response HTML that will hit the '/auth' endpoint that we just created. ",
    "url": "/all-ops/auth/oauthtoken#starting-the-oauth-flow",
    
    "relUrl": "/all-ops/auth/oauthtoken#starting-the-oauth-flow"
  },"148": {
    "doc": "/auth/oAuthToken",
    "title": "The Callback",
    "content": "When we run the code we created, our flow will go like this: . | The page loads, we hit the '/' endpoint. Our heading and anchor render. | We click the anchor, which hits the '/auth' endpoint. This redirects us to the constructed OAuth URL. | We see the Tradovate Login screen! So far so good. We present our credentials. And… | . Nothing ever happens. Or we get an error from express saying cannot /GET. That’s because we never setup a route for our callback. What happens when we present our Tradovate credentials is basically this - your app asks for confirmation that your web identity is accurate. If your user can satisfy the request, the client will receive a single-use code as a response. The response is sent to the REDIRECT_URI address that we specified at the top of the file. The actual code parameter comes to us in the form of the URL query. We can access this using the express Request object (any req parameter within in a route callback). Back in our ROUTES section, add a new route: . app.get('/oauth/tradovate/callback', async (req, res) =&gt; { if (req.query.code) { //req.query.code is the data we've extracted from the URL const credentials = { grant_type: 'authorization_code', client_id: CLIENT_ID, client_secret: CLIENT_SECRET, redirect_uri: REDIRECT_URI, code: req.query.code } //Alright we have a code. How can we exchange our credentials? } }) . We use the req callback parameter’s query field to access parts of the URL query from code. If it’s there, we can easily extract it and put it into an object. We will use these credentials in our exchange. Now how can we go about doing that? . We’re provided with a URL to exchange our code for a token, https://live.tradovate.com/auth/oauthtoken. We can send a POST request to that address with our credentials object in the request form. If all is well, we should be granted an access token. We’ll write a utility function to help us exchange our code: . const exchangeCode = async (userId, form) =&gt; { try { //make a post request with our credentials as the form to the tradovate oauth token exchange endpoint const responseBody = await request.post(EXCHANGE_URL, { form }) //if we got a token const token_data = JSON.parse(responseBody) //check it for errors if(token_data.error) { console.error(`Code Exchange Error: [${token_data.error}] ${token_data.error_description}`) return } //else save the token and expiry all_tokens.set(userId, token_data.access_token, token_data.expires_in) } catch (e) { //catch non-internal errs console.error(`Code Exchange failed.`) return JSON.parse(e.response.body) } } . Our exchangeCode function is an asynchronous function, meaning we can use it with the async/await API. It takes two parameters. userId is the sessionID field of our request. This is preset for us via express-session middleware that we setup in the Getting Setup section. The form parameter will be the credentials object we created in our callback route. We use another of our modules, the request module, to make our POST request. This is where we pass in our URL and our form parameter. We try to parse the response JSON. If we got a standard response, it could have one of two formats. Either we got a token and it has the access_token and expires_in fields, or we received the error form with error and error_description fields. We can account for both here. If we did have a token, we will save the token to our pseudo-database (keep in mind this cache is cleared on each restart). If there was some other unrelated error, it will be caught in the catch block. Now let’s utilize that function in our callback: . app.get('/oauth/tradovate/callback', async (req, res) =&gt; { if (req.query.code) { //req.query.code is the data we've extracted from the URL const credentials = { grant_type: 'authorization_code', client_id: CLIENT_ID, client_secret: CLIENT_SECRET, redirect_uri: REDIRECT_URI, code: req.query.code } //Now we know what to do... //exchange the retrieved code for our real token and store it await exchangeCode(req.sessionID, credentials) //if all is well, we should be authorized to see the authenticated home screen now, so redirect to origin res.redirect(`/`) } }) . If we run the program now, we’ll have our typical flow. But when we submit our credentials, we will be redirected to the home page. There’s only one problem with that - we haven’t forked our logic for the authorized and unauthorized use cases. We’ll simply be presented with the click-to-authenticate screen again. Let’s fix that by splitting up our logic. We can write a helper to cover the case that we’re authenticated: . //write out HTML to display the result of `/me` endpoint const showMe = async (_, res, accessToken) =&gt; { const me = JSON.parse(await request('https://live-api-d.tradovate.com/auth/me', { headers: { Authorization: 'Bearer ' + accessToken } })) //in case of a non trivial amount of HTML, use a template file or one of node's many supported rendering engines. res.write(`&lt;h2&gt;Welcome, ${me.fullName}&lt;/h2&gt;`) res.write(`&lt;p&gt;ID: ${me.userId}&lt;/p&gt;`) res.write(`&lt;p&gt;email: ${me.email}&lt;/p&gt;`) res.write(`&lt;p&gt;verified?: ${me.emailVerified}&lt;/p&gt;`) res.write(`&lt;p&gt;trial?: ${me.isTrial}&lt;/p&gt;`) } . To determine if we’re authenticated, let’s write another helper to get our token: . //retrieve stored token by sessionID, in reality hit the database for this info (this is why we sim async for sync operation) const getAccessToken = async (userId) =&gt; { return all_tokens.get(userId) } . Normally, you’d want to store and retrieve this info with a database, which is why I’ve chosen to simulate this as an asynchronous operation (even though accessing our cache is synchronous). Now we’re equipped to split our home page logic for authorized and unauthorized users: . app.get('/', async (req, res) =&gt; { // we're sending HTML res.setHeader('Content-Type', 'text/html') res.write(`&lt;h2&gt;Tradovate OAuth&lt;/h2&gt;`) //check our token const accessToken = await getAccessToken(req.sessionID) if (accessToken) { //I have a token! Show me `/me` await showMe(req, res, accessToken) } else { //I don't have a token. Show me how to get one. res.write(`&lt;a href=\"/auth\"&gt;&lt;h3&gt;Click to Authenticate&lt;/h3&gt;&lt;/a&gt;`) } //done writing res.end() }) . If we run through our usual flow, we’ll get a response and be redirected home. Our logic should now be properly split and will show the results of '/me' from the Tradovate backend. ",
    "url": "/all-ops/auth/oauthtoken#the-callback",
    
    "relUrl": "/all-ops/auth/oauthtoken#the-callback"
  },"149": {
    "doc": "/auth/oAuthToken",
    "title": "Logout",
    "content": "There’s just one loose end left to take care of. We need to add some logout logic. Let’s add one more route: . app.get('/logout', (req, res) =&gt; { all_tokens.del(req.sessionID) res.redirect('/') }) . In a real world app, you’d probably clear the token from your database. In our example we can simply delete the token associated with the client’s sessionID. Now we just need to add an extra line to our showMe function: . const showMe = async (req, res, accessToken) =&gt; { //... res.write(`&lt;h2&gt;Tradovate OAuth&lt;/h2&gt;`) res.write(`&lt;a href=\"/logout\"&gt;&lt;h3&gt;Logout&lt;/h3&gt;&lt;/a&gt;`) //&lt;-- add this //... } . We can successfully logout using this new anchor after our usual flow. ",
    "url": "/all-ops/auth/oauthtoken#logout",
    
    "relUrl": "/all-ops/auth/oauthtoken#logout"
  },"150": {
    "doc": "/auth/oAuthToken",
    "title": "/auth/oAuthToken",
    "content": " ",
    "url": "/all-ops/auth/oauthtoken",
    
    "relUrl": "/all-ops/auth/oauthtoken"
  },"151": {
    "doc": "/user/openDemoAccount",
    "title": "/user/openDemoAccount",
    "content": " ",
    "url": "/all-ops/user/opendemoaccount",
    
    "relUrl": "/all-ops/user/opendemoaccount"
  },"152": {
    "doc": "Order",
    "title": "Order",
    "content": "Represents an Order to buy or sell a Contract. Related . | Fill | FillPair | Command | CommandReport | ExecutionReport | . Definition . | Property | Tags | Type | Remarks | . | id | none | number, int64 |   | . | accountId | required | number, int64 | ID of the related Account entity which was used to place this order. | . | contractId | none | number, int64 | ID of the related Contract entity. | . | spreadDefinitionId | none | number, int64 | ID of the related SpreadDefinition entity if applicable. | . | timestamp | required | Date string | Time that this order was created. | . | action | required | string enum, \"Buy\" \"Sell\" |   | . | ordStatus | required | string enum, \"Canceled\" \"Completed\" \"Expired\" \"Filled\" \"PendingCancel\" \"PendingNew\" \"PendingReplace\" \"Rejected\" \"Suspended\" \"Unknown\" \"Working\" |   | . | executionProviderId | none | number, int64 | Execution environment ID (LIVE or Sim) | . | ocoId | none | number, int64 | ID of related OCO Entry Order, if applicable. | . | parentId | none | number, int64 | ID of related parent Order, if applicable. | . | linkedId | label | number, int64 | ID of OCO Linked Order (order to be canceled on this order’s Fill), if applicable. | . | admin | required | boolean | false unless you are a Tradovate administrator or are a B2B partner. Will fail if your user does not have administrator status. | . ",
    "url": "/entity-system/entity-index/order",
    
    "relUrl": "/entity-system/entity-index/order"
  },"153": {
    "doc": "OrderStrategy",
    "title": "OrderStrategy",
    "content": "Related . Definition . | Property | Tags | Type | Remarks | . | id | none | number, int64 |   | . | accountId | required | number, int64 | ID of related Account entity. | . | timestamp | required | Date string | Time that this Order Strategy instance was generated. | . | contractId | required | number, int64 | ID of related Contract entity. | . | orderStrategyTypeId | required | number, int64 | This is the ID of the OrderStrategyType entity that this OrderStrategy will utilize. To find the available Order Strategies it is advised that you use the User Sync operation’s initial response, which contains an array of OrderStrategyTypes available to your user. | . | initiatorId | none | number, int64 | Entity ID of the User that initiated this OrderStrategy. | . | action | required | string enum, \"Buy\" \"Sell\" |   | . | params | JSON | string &lt;= 8192 chars | This should be a JSON string with the schema defined in the Notes section below. | . | uuid | none | string &lt;= 64 chars | UUID to identify this OrderStrategy. | . | status | required | string enum, \"ActiveStrategy\" \"ExecutionFailed\" \"ExecutionFinished\" \"ExecutionInterrupted\" \"InactiveStrategy\" \"NotEnoughLiquidity\" \"StoppedByUser\" |   | . | failureMessage | none | string &lt;= 512 chars |   | . | senderId | none | number, int64 | ID of the User who initialized the OrderStrategy. | . | customTag50 | none | string &lt;= 64 chars | Optional descriptive string fewer than 50 characters long (for certain UI display). | . | userSessionId | none | number, int64 |   | . Notes . | The params string should be a JSON string. The schema of the original object should look like this before it is stringified or after it is decoded: //params field shape { entryVersion: { orderQty: number, orderType: \"Limit\" | \"MIT\" | \"Market\" | \"Stop\" | \"StopLimit\" | \"TrailingStop\" | \"TrailingStopLimit\" }, brackets: { qty: number, profitTarget?: number, stopLoss?: number, trailingStop?: boolean }[] } . | . ",
    "url": "/entity-system/entity-index/orderstrategy",
    
    "relUrl": "/entity-system/entity-index/orderstrategy"
  },"154": {
    "doc": "OrderStrategyLink",
    "title": "OrderStrategyLink",
    "content": "Related . | OrderStrategy | Order | OrderStrategyType | . Definition . | Property | Tags | Type | Remarks | . | id | none | number, int64 |   | . | orderStrategyId | required | number, int64 |   | . | orderId | required | number, int64 | ID of the related Order entity. | . | label | required | string &lt;= 64 chars |   | . ",
    "url": "/entity-system/entity-index/orderstrategylink",
    
    "relUrl": "/entity-system/entity-index/orderstrategylink"
  },"155": {
    "doc": "OrderStrategyStatusResponse",
    "title": "OrderStrategyStatusResponse",
    "content": "Expected response from the OrderStrategy’s start, modify, and interrupt operations. Related . | OrderStrategy | . Definition . | Property | Tags | Type | Remarks | . | errorText | none | string | Non-empty if the request failed. | . | orderStrategy | none | OrderStrategy |   | . ",
    "url": "/entity-system/entity-index/orderstrategystatusresponse",
    
    "relUrl": "/entity-system/entity-index/orderstrategystatusresponse"
  },"156": {
    "doc": "OrderStrategyType",
    "title": "OrderStrategyType",
    "content": "Related . Definition . | Property | Tags | Type | Remarks | . | id | none | number, int64 |   | . | name | required | string &lt;= 64 chars |   | . | enabled | required | boolean |   | . ",
    "url": "/entity-system/entity-index/orderstrategytype",
    
    "relUrl": "/entity-system/entity-index/orderstrategytype"
  },"157": {
    "doc": "OrderVersion",
    "title": "OrderVersion",
    "content": "Related . Definition . | Property | Tags | Type | Remarks | . | id | none | number, int64 |   | . | orderId | required | number, int64 | ID of the related Order entity. | . | orderQty | required | number, int32 | Number of Contracts traded by this Order request. | . | orderType | required | string enum, \"Limit\" \"MIT\" \"Market\" \"Stop\" \"StopLimit\" \"TrailingStop\" \"TrailingStopLimit\" |   | . | price | none | number, double |   | . | stopPrice | none | number, double | Required for the \"Stop\", \"StopLimit\", \"TrailingStop\", and \"TrailingStopLimit\" order types. | . | maxShow | none | number, int32 |   | . | pegDifference | none | number, double |   | . | timeInForce | none | string enum, \"Day\" \"FOK\" \"GTC\" \"GTD\" \"IOC\" |   | . | expireTime | none | Date string | Required for \"GTD\" type time-in-force property. | . | text | none | string &lt;= 64 chars |   | . Notes . Time-in-force explanations: . | \"Day\": Good for the current trading session, but cancelled at the end of the day. Be careful not to rely on this for long running stops or take-profit points. | \"FOK\": Fill-or-kill, the entire order must execute as soon as it becomes available or it is cancelled. Good to avoid multiple purchase prices. | \"GTC\": Good ‘til canceled, the order will not expire unless manually canceled by you. | \"GTD\": Good ‘til date, the order will be working until expireTime. | \"IOC\": Immediate or cancel, this order type will fill as much as it can immediately and cancel the remainder. Good for making a move for the maximum available volume at a given price. Ex, say a trader wants to buy 500 contracts at exactly 4100 pts, but if 500 aren’t available at 4100 that trader will take whatever is immediately available for fill by their broker and nothing more, canceling the remainder of the order. | . ",
    "url": "/entity-system/entity-index/orderversion",
    
    "relUrl": "/entity-system/entity-index/orderversion"
  },"158": {
    "doc": "Orders",
    "title": "Orders",
    "content": " ",
    "url": "/all-ops/order",
    
    "relUrl": "/all-ops/order"
  },"159": {
    "doc": "Architecture Overview",
    "title": "Architecture Overview",
    "content": ". Tradovate API . The Tradovate API is an amalgamation of all of our public facing systems. From the API you can access Trade Data, Market Data, and Replay Sessions. Middleware . This is where you, the developers, come in. Your Middlewares will interface with our API to do things. For Retail users, this may be a robot that listens to Market Data streams and waits for certain conditions to take an action. For Vendors, this will be a way to watch your organization members’ actions in real-time. User Entry Points . For Retail users and Vendors alike, the best way to interact with our system is to use one of our client applications. Both the Tradovate or Tradovate applications are available on mobile, web, and desktop. Of course, you could build your own front end using our API, as well - the Tradovate web, mobile, and desktop applications are all built using these same tools. Getting Started REST Guide . ",
    "url": "/architecture-overview",
    
    "relUrl": "/architecture-overview"
  },"160": {
    "doc": "/order/placeOCO",
    "title": "/order/placeOCO",
    "content": "Use this operation to place an OCO type order (AKA. order-cancels-order, one-cancels-other). Request . | Property | Tags | Type | Remarks | . | accountSpec | none | string | This should be the name of the Account placing the trade. | . | accountId | none required | number | This is the Entity ID of the Account being used to place the trade. Optional by the specification, however in practice this is a required field. | . | clOrdId | none | string |   | . | action | required | \"Buy\" \"Sell\" | Basic type of action this order represents. | . | symbol | required | string | The Contract symbol in regards to which this order is being placed. | . | orderQty | required | number | The number of contracts to buy or sell. | . | orderType | required | \"Limit\" \"MIT\" \"Market\" \"Stop\" \"StopLimit\" \"TrailingStop\" \"TrailingStopLimit\" | The specific type of order being placed. More details on these below. | . | price | none | number | This is required for non-\"Market\" type orders. | . | stopPrice | none | number | Required for \"Stop\", \"StopLimit\", \"TrailingStop\", and \"TrailingStopLimit\" order types. | . | maxShow | none | number |   | . | pegDifference | none | number |   | . | timeInForce | none | \"Day\" \"FOK\" \"GTC\" \"GTD\" \"IOC\" | The time that this order is valid for. See this section for more details. | . | expireTime | none | Date string | Required for orders using the \"GTD\" timeInForce property. | . | activationTime | none | Date string |   | . | customTag50 | none | string | Used by the Trader UI to show custom descriptions. | . | isAutomated | none | boolean | Must be true if the order was not placed by a human clicking a button. | . | other | required | RestrainedOrderVersion | The paired order - if the entry order is filled the other will be cancelled, and vice-versa. | . Response . PlaceOCOResult . Example . ",
    "url": "/all-ops/order/placeoco#orderplaceoco",
    
    "relUrl": "/all-ops/order/placeoco#orderplaceoco"
  },"161": {
    "doc": "/order/placeOCO",
    "title": "/order/placeOCO",
    "content": " ",
    "url": "/all-ops/order/placeoco",
    
    "relUrl": "/all-ops/order/placeoco"
  },"162": {
    "doc": "PlaceOcoResult",
    "title": "PlaceOcoResult",
    "content": "Expected result object from a request to /order/placeOCO. Related . | Order | Command | CommandReport | ExecutionReport | . Definition . | Property | Tags | Type | Remarks | . | failureReason | none | \"AccountClosed\" \"AdvancedTrailingStopUnsupported\" \"AnotherCommandPending\" \"BackMonthProhibited\" \"ExecutionProviderNotConfigured\" \"ExecutionProviderUnavailable\" \"InvalidContract\" \"InvalidPrice\" \"LiquidationOnly\" \"LiquidationOnlyBeforeExpiration\" \"MaxOrderQtyIsNotSpecified\" \"MaxOrderQtyLimitReached\" \"MaxPosLimitMisconfigured\" \"MaxPosLimitReached\" \"MaxTotalPosLimitReached\" \"MultipleAccountPlanRequired\" \"NoQuote\" \"NotEnoughLiquidity\" \"OtherExecutionRelated\" \"ParentRejected\" \"RiskCheckTimeout\" \"SessionClosed\" \"Success\" \"TooLate\" \"TradingLocked\" \"TrailingStopNonOrderQtyModify\" \"Unauthorized\" \"UnknownReason\" \"Unsupported\" |   | . | failureText | none | string | Non-empty if the request passed at the HTTP level, but failed a check on the server. | . | orderId | none | number | Linked Order. | . | ocoId | none | number | other linked Order. | . ",
    "url": "/entity-system/entity-index/placeocoresult",
    
    "relUrl": "/entity-system/entity-index/placeocoresult"
  },"163": {
    "doc": "/order/placeOSO",
    "title": "/order/placeOSO",
    "content": "Use this operation to place an OSO type order (AKA. order-sends-order, one-sends-other). Request . | Property | Tags | Type | Remarks | . | accountSpec | none | string | This should be the name of the Account placing the trade. | . | accountId | none required | number | This is the Entity ID of the Account being used to place the trade. Optional by the specification, however in practice this is a required field. | . | clOrdId | none | string |   | . | action | required | \"Buy\" \"Sell\" | Basic type of action this order represents. | . | symbol | required | string | The Contract symbol in regards to which this order is being placed. | . | orderQty | required | number | The number of contracts to buy or sell. | . | orderType | required | \"Limit\" \"MIT\" \"Market\" \"Stop\" \"StopLimit\" \"TrailingStop\" \"TrailingStopLimit\" | The specific type of order being placed. More details on these below. | . | price | none | number | This is required for non-\"Market\" type orders. | . | stopPrice | none | number | Required for \"Stop\", \"StopLimit\", \"TrailingStop\", and \"TrailingStopLimit\" order types. | . | maxShow | none | number |   | . | pegDifference | none | number |   | . | timeInForce | none | \"Day\" \"FOK\" \"GTC\" \"GTD\" \"IOC\" | The time that this order is valid for. See this section for more details. | . | expireTime | none | Date string | Required for orders using the \"GTD\" timeInForce property. | . | activationTime | none | Date string |   | . | customTag50 | none | string | Used by the Trader UI to show custom descriptions. | . | isAutomated | none | boolean | Must be true if the order was not placed by a human clicking a button. | . | bracket1 | required | RestrainedOrderVersion |   | . | bracket2 | none | RestrainedOrderVersion | Optional bracket. Use a single bracket for only stop-loss or take-profit alone. Use both brackets to set up stop-loss and take-profit orders. | . Response . PlaceOSOResult . Notes . ",
    "url": "/all-ops/order/placeoso#orderplaceoso",
    
    "relUrl": "/all-ops/order/placeoso#orderplaceoso"
  },"164": {
    "doc": "/order/placeOSO",
    "title": "/order/placeOSO",
    "content": " ",
    "url": "/all-ops/order/placeoso",
    
    "relUrl": "/all-ops/order/placeoso"
  },"165": {
    "doc": "PlaceOsoResult",
    "title": "PlaceOsoResult",
    "content": "Expected server response object when calling the /order/placeOrder operation. Related . | Order | Command | CommandReport | ExecutionReport | . Definition . | Property | Tags | Type | Remarks | . | failureReason | none | \"AccountClosed\" \"AdvancedTrailingStopUnsupported\" \"AnotherCommandPending\" \"BackMonthProhibited\" \"ExecutionProviderNotConfigured\" \"ExecutionProviderUnavailable\" \"InvalidContract\" \"InvalidPrice\" \"LiquidationOnly\" \"LiquidationOnlyBeforeExpiration\" \"MaxOrderQtyIsNotSpecified\" \"MaxOrderQtyLimitReached\" \"MaxPosLimitMisconfigured\" \"MaxPosLimitReached\" \"MaxTotalPosLimitReached\" \"MultipleAccountPlanRequired\" \"NoQuote\" \"NotEnoughLiquidity\" \"OtherExecutionRelated\" \"ParentRejected\" \"RiskCheckTimeout\" \"SessionClosed\" \"Success\" \"TooLate\" \"TradingLocked\" \"TrailingStopNonOrderQtyModify\" \"Unauthorized\" \"UnknownReason\" \"Unsupported\" |   | . | failureText | none | string | Non-empty if the request passed at the HTTP level, but failed a check on the server. | . | orderId | none | number | The entry Order entity. | . | oso1Id | none | number | One of up to two linked Order entities. | . | oso2Id | none | number | One of up to two linked Order entities. | . ",
    "url": "/entity-system/entity-index/placeosoresult",
    
    "relUrl": "/entity-system/entity-index/placeosoresult"
  },"166": {
    "doc": "/order/placeOrder",
    "title": "/order/placeOrder",
    "content": "Use this operation to make a request to place an order. Request . | Property | Tags | Type | Remarks | . | accountSpec | none | string | This should be the name of the Account placing the trade. | . | accountId | none required | number | This is the Entity ID of the Account being used to place the trade. Optional by the specification, however in practice this is a required field. | . | clOrdId | none | string |   | . | action | required | \"Buy\" \"Sell\" | Basic type of action this order represents. | . | symbol | required | string | The Contract symbol in regards to which this order is being placed. | . | orderQty | required | number | The number of contracts to buy or sell. | . | orderType | required | \"Limit\" \"MIT\" \"Market\" \"Stop\" \"StopLimit\" \"TrailingStop\" \"TrailingStopLimit\" | The specific type of order being placed. More details on these below. | . | price | none | number | This is required for non-\"Market\" type orders. | . | stopPrice | none | number | Required for \"Stop\", \"StopLimit\", \"TrailingStop\", and \"TrailingStopLimit\" order types. | . | maxShow | none | number |   | . | pegDifference | none | number |   | . | timeInForce | none | \"Day\" \"FOK\" \"GTC\" \"GTD\" \"IOC\" | The time that this order is valid for. See this section for more details. | . | expireTime | none | Date string | Required for orders using the \"GTD\" timeInForce property. | . | activationTime | none | Date string |   | . | customTag50 | none | string | Used by the Trader UI to show custom descriptions. | . | isAutomated | none | boolean | Must be true if the order was not placed by a human clicking a button. | . Response . PlaceOrderResult . Example . const URL = 'https://demo.tradovateapi.com/v1' //or live //here are some props we can share across our orders for this example const baseBody = { accountSpec: yourAcctName, //controls the label in the Trader UI accountId: yourAcctId, //ID of Account to trade symbol: \"ESU3\", //contract symbol orderQty: 1, //number of contracts to trade isAutomated: true //must be true if this isn't an order made directly by a human } //market order requires none of the optional parameters const marketBody = { ...baseBody, action: 'Buy', orderType: 'Market' } //we need a stopPrice for a stop order const stopBody = { ...baseBody, action: 'Sell', orderType: 'Stop', stopPrice: 3888.25 } //just the same as Stop order, but orderType matches const trailingStopBody = { ...baseBody, action: 'Stop', orderType: 'TrailingStop', stopPrice: 3888.25 //will keep a max distance of (positionPrice - stopPrice) } //use the price parameter for limit orders const limitBody = { ...baseBody, action: 'Sell', orderType: 'Limit', price: 3891.25, //use for single value like limit or stop } const response = await fetch(URL + '/order/placeorder', { method: 'POST', headers: { 'Accept': 'application/json', 'Authorization': `Bearer ${myAccessToken}`, }, body: JSON.stringify(marketBody) //replace with any of above request bodies }) const json = await response.json() //=&gt; { orderId: 0000000 } . Related . | /order/modifyOrder | /order/cancelOrder | /order/liquidatePosition | . ",
    "url": "/all-ops/order/placeorder#orderplaceorder",
    
    "relUrl": "/all-ops/order/placeorder#orderplaceorder"
  },"167": {
    "doc": "/order/placeOrder",
    "title": "/order/placeOrder",
    "content": " ",
    "url": "/all-ops/order/placeorder",
    
    "relUrl": "/all-ops/order/placeorder"
  },"168": {
    "doc": "PlaceOrderResult",
    "title": "PlaceOrderResult",
    "content": "Expected server response object when calling the /order/placeOrder operation. Related . | Order | Command | CommandReport | ExecutionReport | . Definition . | Property | Tags | Type | Remarks | . | failureReason | none | \"AccountClosed\" \"AdvancedTrailingStopUnsupported\" \"AnotherCommandPending\" \"BackMonthProhibited\" \"ExecutionProviderNotConfigured\" \"ExecutionProviderUnavailable\" \"InvalidContract\" \"InvalidPrice\" \"LiquidationOnly\" \"LiquidationOnlyBeforeExpiration\" \"MaxOrderQtyIsNotSpecified\" \"MaxOrderQtyLimitReached\" \"MaxPosLimitMisconfigured\" \"MaxPosLimitReached\" \"MaxTotalPosLimitReached\" \"MultipleAccountPlanRequired\" \"NoQuote\" \"NotEnoughLiquidity\" \"OtherExecutionRelated\" \"ParentRejected\" \"RiskCheckTimeout\" \"SessionClosed\" \"Success\" \"TooLate\" \"TradingLocked\" \"TrailingStopNonOrderQtyModify\" \"Unauthorized\" \"UnknownReason\" \"Unsupported\" |   | . | failureText | none | string | Non-empty if the request passed at the HTTP level, but failed a check on the server. | . | orderId | none | number | Related Order entity. | . ",
    "url": "/entity-system/entity-index/placeorderresult",
    
    "relUrl": "/entity-system/entity-index/placeorderresult"
  },"169": {
    "doc": "Position",
    "title": "Position",
    "content": "An entity that is used to describe a Position held over a certain Contract for a given Account. Related . | Account | Order | Contract | Fill | FillPair | . Definition . | Property | Tags | Type | Remarks | . | id | none | number, int64 |   | . | accountId | required | number, int64 | ID of the related Account entity for which this Position is held. | . | contractId | required | number, int64 | ID of the related Contract entity that this Position was taken for. | . | timestamp | required | Date string | Time that this Position was created. | . | tradeDate | required | TradeDate | Trading Session Date on which this Position was created. | . | netPos | required | number, int32 | The net position or number of instances you hold of the given Contract. | . | netPrice | none | number, double | The total combined price that was paid for the Contract instances that make up this Position. | . | bought | required | number, int32 | The number of times you placed Buy orders for the given Contract during this Trading Session that accounted for this Position. | . | boughtValue | required | number, double | The combined value of all of the Buy orders you placed for the given Contract over the course of this Trading Session. | . | sold | required | number, int32 | The number of times you placed Sell orders for the given Contract during this Trading Session that accounted for this Position. | . | soldValue | required | number, double | The combined value of all the Sell orders you placed for the given Contract over the course of this Trading Session. | . | prevPos | required | number, int32 | Position previously held during this Trading Week. | . | prevPrice | none | number, double | Last known price for your previously held Position. | . ",
    "url": "/entity-system/entity-index/position",
    
    "relUrl": "/entity-system/entity-index/position"
  },"170": {
    "doc": "Product",
    "title": "Product",
    "content": "Related . | Position | Contract | ProductMargin | . Definition . | Property | Tag | Type | Remarks | . | id | none | number, int64 |   | . | name | required | string &lt;= 64 chars | The name of this product, ex. ES, MES, NQ, MNQ, etc. Product names do not include contract expiration codes (ES~M2~, NQ~Z4~, etc.). | . | currencyId | required | number, int64 | The currency that backs this product. See Currency. | . | productType | required | string enum, \"CommonStock\", \"Continuous\", \"Cryptocurrency\", \"Futures\", \"MarketInternals\", \"Options\", \"Spread\" | The type of tradable product that this Product entity represents. | . | description | required | string &lt;= 8192 chars | A short description of what this product represents. | . | exchangeId | required | number, int64 | The Exchange entity that this product is listed as a member of. | . | contractGroupId | required | number, int64 |   | . | riskDiscountContractGroupId | none | number, int64 |   | . | status | required | string enum, \"Inactive\", \"Locked\", \"ReadyForContracts\", \"ReadyToTrade\", \"Verified\" |   | . | months | none | string &lt;= 64 chars | The expiration-month codes available for this product. For example, ES uses H, M, U, and Z month codes. | . | isSecured | none | boolean |   | . | valuePerPoint | required | number, double | This is an important property of the Product entity for calculating real-time P&amp;L, when combined with the tickSize field. | . | priceFormatType | required | string enum, \"Decimal\", \"Fractional\" |   | . | priceFormat | required | number, int32 |   | . | tickSize | required | number, double | Useful for calculating open P&amp;L in real-time when combined with the valuePerPoint field. | . Notes . You can use the Product entity to help you calculate your real-time open P&amp;L. You need the current price, your entry price or net held price, the value-per-point of the product in question, and the net position you are holding. You can determine the net held price by using the position’s netPrice field. See Position for more details. You can use this formula to calculate real-time open P&amp;L for a single product: . (currentPrice - netHeldPrice) * valuePerPoint * position.netPos . To find the net P&amp;L for all products you can simply run this operation for each product that you hold a position for and then sum the results. ",
    "url": "/entity-system/entity-index/product",
    
    "relUrl": "/entity-system/entity-index/product"
  },"171": {
    "doc": "ProductFeeParamsResponse",
    "title": "ProductFeeParamsResponse",
    "content": " ",
    "url": "/entity-system/entity-index/productfeeparamsresponse",
    
    "relUrl": "/entity-system/entity-index/productfeeparamsresponse"
  },"172": {
    "doc": "ProductMargin",
    "title": "ProductMargin",
    "content": "You can use this object to find the margin requirements for a product. Related . | Product | . Definition . | Property | Tags | Type | Remarks | . | id | none | number, int64 |   | . | initialMargin | required | number, double |   | . | maintenanceMargin | required | number, double |   | . | timestamp | required | Date string |   | . ",
    "url": "/entity-system/entity-index/productmargin",
    
    "relUrl": "/entity-system/entity-index/productmargin"
  },"173": {
    "doc": "ProductSession",
    "title": "ProductSession",
    "content": "Represents the weekly open/close schedule for this product not considering holidays. Related . | Product | ProductMargin | . Definition . | Property | Tags | Type | Remarks | . | id | none | number, int64 |   | . | openTime | required | TradeTime |   | . | startTime | required | TradeTime |   | . | stopTime | required | TradeTime |   | . | closeTime | required | TradeTime |   | . | sundayOpenTime | label | TradeTime |   | . ",
    "url": "/entity-system/entity-index/productsession",
    
    "relUrl": "/entity-system/entity-index/productsession"
  },"174": {
    "doc": "/auth/renewAccessToken",
    "title": "/auth/renewAccessToken",
    "content": "This operation is used to renew an API session’s expiration time. Request . | Property | Tags | Type | Remarks | . | &lt;none&gt; | none | &lt;none&gt; | (Simple GET request) | . Response . AccessTokenResponse . Example . async function renewAccessToken() { let response, data try { //you'll need to have an access token stored that you want to renew const accessToken = myRetrieveAccessTokenFromStorageFn() response = await fetch('https://live.tradovateapi.com/v1/auth/renewAccessToken', { method: 'GET', headers: { 'Authorization': `Bearer ${accessToken}`. 'Accept': 'application/json', 'Content-Type': 'application/json' } }) data = await response.json() } catch(err) { console.error(err) } return data } . ",
    "url": "/all-ops/auth/renewaccesstoken#authrenewaccesstoken",
    
    "relUrl": "/all-ops/auth/renewaccesstoken#authrenewaccesstoken"
  },"175": {
    "doc": "/auth/renewAccessToken",
    "title": "/auth/renewAccessToken",
    "content": " ",
    "url": "/all-ops/auth/renewaccesstoken",
    
    "relUrl": "/all-ops/auth/renewaccesstoken"
  },"176": {
    "doc": "/user/requestTradingPermission",
    "title": "/user/requestTradingPermission",
    "content": " ",
    "url": "/all-ops/user/requesttradingpermission",
    
    "relUrl": "/all-ops/user/requesttradingpermission"
  },"177": {
    "doc": "/account/resetDemoAccountState",
    "title": "/account/resetDemoAccountState",
    "content": "Reset one or more accounts’ state to its Start-of-day state on a given TradeDate . Related . | cashbalance/changeDemoBalance | . Request . | Property | Tags | Type | Remarks | . | accountIds | required | Array | A list of Account IDs to reset. | . | resetTradeDate | required | TradeDate | The TradeDate session you want to reset these accounts’ states to. | . ",
    "url": "/all-ops/account/resetdemoaccountstate#accountresetdemoaccountstate",
    
    "relUrl": "/all-ops/account/resetdemoaccountstate#accountresetdemoaccountstate"
  },"178": {
    "doc": "/account/resetDemoAccountState",
    "title": "/account/resetDemoAccountState",
    "content": " ",
    "url": "/all-ops/account/resetdemoaccountstate",
    
    "relUrl": "/all-ops/account/resetdemoaccountstate"
  },"179": {
    "doc": "Resources",
    "title": "Resources",
    "content": "Here, you will find additional suggested content and resources to help you learn the Tradovate API. WebSocket Playground . Connect to any of the Tradovate WebSocket servers and interact with real-time data right here on this site. WebSocket Playground . All Tradovate API Operations . An index of all the operations you can call from the Tradovate REST and WebSocket APIs. All Operations . All Tradovate Entity Types . An index of every entity type that you could encounter while using the Tradovate REST and WebSocket APIs. Entities Index . Official API Docs . Tradovate’s official API documentation. API Docs . API FAQ . Repository for API-related frequently asked questions and example code. API FAQ . Tradovate Community . When you just can’t find what you’re looking for, sometimes the community is the best place to go. You may even get help from the author of this guide! . Tradovate Community . ",
    "url": "/resources/",
    
    "relUrl": "/resources/"
  },"180": {
    "doc": "Requesting API Access",
    "title": "Retrieving an Access Token",
    "content": "To retrieve an Access Token we will need to make a request to the API. Below is the URL that you could use to initiate an accessTokenRequest operation on the Demo (simulation) environment: . const URL = 'https://demo.tradovateapi.com/v1/auth/accessTokenRequest'; . You’ll need your login credentials and API Key information to make the request successfully. They will look like this: . const credentials = { \"name\": \"your_username\", \"password\": \"your_password_or_api_dedicated_password\", \"appId\": \"your_app_nickname\", \"appVersion\": \"1.0\", \"cid\": 0, \"sec\": \"your_api_secret\" } . Many of these are self-explanatory. In the case of dedicated API passwords, this is an API Key Config option you set when you setup your key. It is used to protect your real password, should the credentials become compromised. You can edit most of your key’s settings later from the API Access section of the Trader Application, so don’t worry too much about this yet. It is advised for testing, however, that you set your key’s permissions to the highest available levels for each setting. You can always drop permissions you don’t need later. ",
    "url": "/rest-guide/access-token-request/#retrieving-an-access-token",
    
    "relUrl": "/rest-guide/access-token-request/#retrieving-an-access-token"
  },"181": {
    "doc": "Requesting API Access",
    "title": "Calling the accessTokenRequest Operation",
    "content": "The simplest way to try this with no overhead is by using cURL: . curl -X 'POST' \\ 'https://demo.tradovateapi.com/v1/auth/accesstokenrequest' \\ -H 'accept: application/json' \\ -H 'Content-Type: application/json' \\ -d '{ \"name\": \"string\", \"password\": \"string\", \"appId\": \"string\", \"appVersion\": \"string\", \"deviceId\": \"string\", \"cid\": 0, \"sec\": \"string\" }' . But many applications use JavaScript: . /** * Call the `/auth/accessTokenRequest` endpoint. * * @param credentials * @returns {Promise&lt;{ errorText: string } | { accessToken: string, expirationTime: string, passwordExpirationTime: string, userStatus: 'Active' | 'Closed' | 'Initiated' | 'TemporarilyLocked' | 'UnconfirmedEmail', userId: number, name: string, hasLive: boolean }&gt;} */ async function accessTokenRequest(credentials) { const config = { method: 'POST', headers: { 'Accept': 'application/json', 'Content-Type': 'application/json' }, body: JSON.stringify(credentials) } let response try { response = await fetch('https://demo.tradovateapi.com/v1/auth/accesstokenrequest', config) response = await response.json() } catch (err) { console.error(err) } return response } . REST Guide Constructing Headers . ",
    "url": "/rest-guide/access-token-request/#calling-the-accesstokenrequest-operation",
    
    "relUrl": "/rest-guide/access-token-request/#calling-the-accesstokenrequest-operation"
  },"182": {
    "doc": "Requesting API Access",
    "title": "Requesting API Access",
    "content": " ",
    "url": "/rest-guide/access-token-request/",
    
    "relUrl": "/rest-guide/access-token-request/"
  },"183": {
    "doc": "Constructing HTTP Headers",
    "title": "How to Construct Your HTTP Headers",
    "content": "Aside from the /auth/accessTokenRequest operation, the API should know how to construct our HTTP headers. Luckily this is very simple. Let’s strip away the pre-built implementation and work with the browser’s built in fetch function. aysnc function main() { const resp = await fetch('https://demo.tradovateapi.com/v1/auth/accessTokenRequest', { method: 'POST', headers: { 'Accept': 'application/json', 'Content-Type': 'application/json' }, body: JSON.stringify(credentials) }) const json = await resp.json() console.log(json) } . This is an expansion of what the accessTokenRequest built-in function actually does. As we see, the fetch method takes a config object as its second parameter. In this object you may specify the headers field to include the headers necessary to complete your requests. ",
    "url": "/rest-guide/construct-headers/#how-to-construct-your-http-headers",
    
    "relUrl": "/rest-guide/construct-headers/#how-to-construct-your-http-headers"
  },"184": {
    "doc": "Constructing HTTP Headers",
    "title": "Authorization",
    "content": "For the Access Token request, we don’t need to include any Authorization headers. But for nearly every other API call, we will need to include our Access Token as a part of the Authorization header. async function main() { const resp = await fetch('https://demo.tradovateapi.com/v1/account/list', { method: 'GET', headers: { 'Accept': 'application/json', 'Content-Type': 'application/json', 'Authorization': `Bearer ${myAccessToken}` } }) const json = await resp.json() console.log(json) } . We must use the ‘Bearer’ schema for our Authorization header. For every call other than the initial accessTokenRequest, we should use these headers. Here’s a helper function to construct these headers with a single call. It will also only include the Authorization header if an accessToken is provided. buildHeaders Helper Function . export function buildHeaders(accessToken) { let auth = {} if(accessToken) { auth = { Authorization: `Bearer ${accessToken}` } } return { headers: { ...auth, 'Content-Type': 'application/json', 'Accept': 'application/json' } } } . Requesting API Access Device IDs . ",
    "url": "/rest-guide/construct-headers/#authorization",
    
    "relUrl": "/rest-guide/construct-headers/#authorization"
  },"185": {
    "doc": "Constructing HTTP Headers",
    "title": "Constructing HTTP Headers",
    "content": " ",
    "url": "/rest-guide/construct-headers/",
    
    "relUrl": "/rest-guide/construct-headers/"
  },"186": {
    "doc": "How to Use Device IDs",
    "title": "How to Use Device IDs Properly",
    "content": "You may have noticed the deviceId field in the body of /auth/accessTokenRequest. This is a very important part of obtaining an access token - on simulation mode, device IDs aren’t strictly enforced - you can trade with an Access Token that was acquired with an unverified/no device ID; LIVE mode strictly enforces that you use a verified device for trading (so that some stranger with your credentials can’t place trades using an account you own). This is a good thing! . To understand device IDs, let’s discuss their properties and usage. ",
    "url": "/rest-guide/device-id/#how-to-use-device-ids-properly",
    
    "relUrl": "/rest-guide/device-id/#how-to-use-device-ids-properly"
  },"187": {
    "doc": "How to Use Device IDs",
    "title": "Properties of a Device ID",
    "content": "A proper Device ID must possess two qualities: . | The ID must be unique. No other device can possess the same ID. | The ID must always be the same for a given device. PC A must always have the same ID, but unique from from PC B’s ID. | . These traits are understandable - each device must be identifiable in order to be eligible for authorization to make real-money trades. ",
    "url": "/rest-guide/device-id/#properties-of-a-device-id",
    
    "relUrl": "/rest-guide/device-id/#properties-of-a-device-id"
  },"188": {
    "doc": "How to Use Device IDs",
    "title": "How Can I Create a Device ID?",
    "content": "There are several ways that we can create device IDs. Here are a two that rely on the third party softwares device-uuid (here) and crypto-browserify (here) respectively. Using device-uuid . /** * Derive a device ID from credentials and app secret using the device-uuid package. * @returns {Promise&lt;string&gt;} */ async function createDeviceId_DeviceUUID(mySecret, credentials) { const deviceId = new DeviceUUID() return deviceId.get({ secret: mySecret, name: credentials.name, password: credentials.password }) } . Using crypto-browserify . /** * Derive a device ID from credentials and app secret using the crypto-browserify package. * @returns {Promise&lt;string&gt;} */ async function createDeviceId_CryptoBrowserify(mySecret, credentials) { return createHash('sha256') .update(mySecret) .update(credentials.name) .update(credentials.password) .digest('hex') } . Usage with Credentials . We can mix our Device ID into our credentials object before we send the accessTokenRequest: . //a value unique to your application that we can use to hash our device IDs //this will always have the same value (unless you change the phrase) const mySecret = createHash('sha256') .update('My Special Pass-Phrase') .digest('hex') const deviceId = await createDeviceId_CryptoBrowserify(credentials) const credsWithId = { ...credentials, deviceId } const userAccessData = API.auth.accessTokenRequest({ credentials: credsWithId }) . Try it! Generate an ID . *Uses the device-uuid package. How to Construct Headers Renewing Your Access Token . ",
    "url": "/rest-guide/device-id/#how-can-i-create-a-device-id",
    
    "relUrl": "/rest-guide/device-id/#how-can-i-create-a-device-id"
  },"189": {
    "doc": "How to Use Device IDs",
    "title": "How to Use Device IDs",
    "content": " ",
    "url": "/rest-guide/device-id/",
    
    "relUrl": "/rest-guide/device-id/"
  },"190": {
    "doc": "Place An Order",
    "title": "Place An Order via REST API",
    "content": "The most straightforward way to place an order is to just use the fetch function built-in to any browser. async function placeOrder(config) { const { accessToken } = Storage.getUserData() const { accountSpec, accountId, symbol, orderQty, isAutomated, action, orderType } = config let response try { await response = fetch('https://demo.tradovateapi.com/v1/order/placeOrder', { method: 'POST', headers: buildHeaders(accessToken), body: JSON.stringify({ accountSpec, accountId, symbol, orderQty, isAutomated, action, orderType }) }) response = await response.json() } catch(err) { console.error(err) } return response } . Storing User Data Entity System . ",
    "url": "/rest-guide/place-an-order/#place-an-order-via-rest-api",
    
    "relUrl": "/rest-guide/place-an-order/#place-an-order-via-rest-api"
  },"191": {
    "doc": "Place An Order",
    "title": "Place An Order",
    "content": " ",
    "url": "/rest-guide/place-an-order/",
    
    "relUrl": "/rest-guide/place-an-order/"
  },"192": {
    "doc": "Renewing Your Access Token",
    "title": "Renewing Your Access Token",
    "content": "Over the course of the development process, you’ll eventually encounter your token reaching it’s expiration time. Once a token has exceeded its expiration, REST calls made using it will return 400 or 401 errors. If the token is within a few minutes of expiration we should call /auth/renewAccessToken. Calling /auth/renewAccessToken . Renewing your access token is much easier than retrieving the original. It’s a simple GET request with no parameters, it simply relies on including the token in the Authorization header of the request. We can use the buildHeaders function which we defined in a previous auth section to create the expected headers. async function renewAccessProcedure(token) { const headers = buildHeaders(token) let response try { response = await fetch('https://demo.tradovateapi.com/v1/auth/renewAccessToken', { method: 'GET', headers }) response = await response.json() } catch(err) { console.error(err) } return response } . Using Device IDs Place An Order . ",
    "url": "/rest-guide/renewing-access/#renewing-your-access-token",
    
    "relUrl": "/rest-guide/renewing-access/#renewing-your-access-token"
  },"193": {
    "doc": "Renewing Your Access Token",
    "title": "Renewing Your Access Token",
    "content": " ",
    "url": "/rest-guide/renewing-access/",
    
    "relUrl": "/rest-guide/renewing-access/"
  },"194": {
    "doc": "REST Guide",
    "title": "REST Guide",
    "content": " ",
    "url": "/rest-guide/",
    
    "relUrl": "/rest-guide/"
  },"195": {
    "doc": "REST Guide",
    "title": "Introduction",
    "content": "In this section we’ll be discussing the endpoints related to gaining Access to the API, and using the REST portion of the API. Before we can begin calling operative endpoints on the API, we will need to ask the API for an Access Token. We need to understand how Device IDs work, and how to construct our HTTP headers. We’ll also need to periodically renew our Access Token for sessions that range beyond its original expiration. ",
    "url": "/rest-guide/#introduction",
    
    "relUrl": "/rest-guide/#introduction"
  },"196": {
    "doc": "REST Guide",
    "title": "REST API Facts",
    "content": "Before you begin using the Tradovate REST API, there are a few things you should keep in mind: . | Our API does not mandate method protocols. However, we do recommend the GET method for requests with query parameters (or no parameters), and the POST method for requests with JSON bodies. | Both 'Accept' and 'Content-Type' headers can be set to the 'application/json' MIME type. We’ll discuss the 'Authorization' header soon. | We offer an OpenAPI Specification for the REST API. Look at the main page’s download buttons - we have both JSON and YAML versions available. | The REST API is partitioned into two parts - DEMO and LIVE. They are virtually identical but each correspond to their respective trading environment. You can access a different environment via API by changing the prefix on the tradovateapi.com domain (demo.tradovateapi.com, live.tradovateapi.com). | . ",
    "url": "/rest-guide/#rest-api-facts",
    
    "relUrl": "/rest-guide/#rest-api-facts"
  },"197": {
    "doc": "REST Guide",
    "title": "Common Pitfalls",
    "content": ". | Always 404 for entities you know exist? Double check your URL prefix. It is likely you’re accessing the wrong environment. | Always 401 beyond accessTokenRequest? Check your API Key permissions in the Trader Application’s API Settings tab. The default settings for API Keys is to have each permission domain set to be inaccessible. | . Getting Started Access Token Request . ",
    "url": "/rest-guide/#common-pitfalls",
    
    "relUrl": "/rest-guide/#common-pitfalls"
  },"198": {
    "doc": "RestrainedOrderVersion",
    "title": "RestrainedOrderVersion",
    "content": "Related . | Order | OrderVersion | . Definition . | Property | Tags | Type | Remarks | . | action | required | string enum, \"Buy\" \"Sell\" |   | . | clOrdId | none | string &lt;= 64 chars |   | . | orderType | required | string enum, \"Limit\" \"MIT\" \"Market\" \"Stop\" \"StopLimit\" \"TrailingStop\" \"TrailingStopLimit\" |   | . | price | none | number, double |   | . | stopPrice | none | number, double | Required for the \"Stop\", \"StopLimit\", \"TrailingStop\", and \"TrailingStopLimit\" order types. | . | maxShow | none | number, int32 |   | . | pegDifference | none | number, double |   | . | timeInForce | none | string enum, \"Day\" \"FOK\" \"GTC\" \"GTD\" \"IOC\" |   | . | expireTime | none | Date string | Required for \"GTD\" type time-in-force property. | . | text | none | string &lt;= 64 chars |   | . ",
    "url": "/entity-system/entity-index/restrainedorderversion",
    
    "relUrl": "/entity-system/entity-index/restrainedorderversion"
  },"199": {
    "doc": "/user/revokeTradingPermission",
    "title": "/user/revokeTradingPermission",
    "content": " ",
    "url": "/all-ops/user/revoketradingpermission",
    
    "relUrl": "/all-ops/user/revoketradingpermission"
  },"200": {
    "doc": "/user/revokeTradingPermissions",
    "title": "/user/revokeTradingPermissions",
    "content": " ",
    "url": "/all-ops/user/revoketradingpermissions",
    
    "relUrl": "/all-ops/user/revoketradingpermissions"
  },"201": {
    "doc": "Risks",
    "title": "Risks",
    "content": " ",
    "url": "/all-ops/risks",
    
    "relUrl": "/all-ops/risks"
  },"202": {
    "doc": "/contract/rollContract",
    "title": "/contract/rollContract",
    "content": " ",
    "url": "/all-ops/contract/rollcontract",
    
    "relUrl": "/all-ops/contract/rollcontract"
  },"203": {
    "doc": "/accountRiskStatus/setDemoHalt",
    "title": "/accountRiskStatus/setDemoHalt",
    "content": " ",
    "url": "/all-ops/accountriskstatus/setdemohalt",
    
    "relUrl": "/all-ops/accountriskstatus/setdemohalt"
  },"204": {
    "doc": "Shared",
    "title": "Shared",
    "content": "Here you can find all of the operations that are shared across Entity types. With some limitations, these endpoints are valid for any Entity. See the detail-pages and the Entities’ Shared Ops section of the guide for more info about using the shared operations. ",
    "url": "/all-ops/shared",
    
    "relUrl": "/all-ops/shared"
  },"205": {
    "doc": "REST API vs. WebSocket API",
    "title": "REST API vs WebSocket API",
    "content": "Because the REST and WebSocket APIs are split up by functionality, it follows that the optimal use cases for either API will vary. Here are some common examples of when to choose the REST API and when to choose a WebSocket. When to Use the REST API . | Authentication - you can only authenticate your application for API access using the REST API’s auth/accessTokenRequest using your Tradovate credentials and one of your personal secret keys. | Non-subscribing requests - If you want to place an order, find an entity by ID, or search for an entity by name, it is perfectly acceptable to do so using the REST API. There are even options for batch-loading large requests using the /ldeps endpoints. | OAuth - If you’d like to opt for authentication via OAuth, you will need to use REST operations to do so, but beyond the OAuth grant you aren’t limited to one of REST or WebSocket protocols. | Changing Account Risk status - creating or modifying risk limits are non-subscribing and can be acceptably called from the REST API. | . When to Use the WebSockets API . | Listening to user property events - anytime we create or modify a user property (entering a position, executing a command, filling an order, changes to cash-balance, and many more) we can listen to them using a Real-Time socket and subscribing to the user/syncRequest endpoint. | Getting Market Data - when we want to receive quote, DOM, chart, or histogram data in real-time. | Starting a Market Replay session. | Finding a change in user data in response to performing an action. Scenario: You’ve placed an order and now you want to find what your new position is. You can try to find the position itself via REST API, but it would be more efficient to listen to the real-time user properties events and wait for a Position update. This way we can be ‘reactive’ to incoming data instead of always looking out and asking in a client-driven manner. | . ",
    "url": "/api-faq/rest-vs-wss#rest-api-vs-websocket-api",
    
    "relUrl": "/api-faq/rest-vs-wss#rest-api-vs-websocket-api"
  },"206": {
    "doc": "REST API vs. WebSocket API",
    "title": "REST API vs. WebSocket API",
    "content": " ",
    "url": "/api-faq/rest-vs-wss",
    
    "relUrl": "/api-faq/rest-vs-wss"
  },"207": {
    "doc": "/user/signupOrganizationMember",
    "title": "/user/signupOrganizationMember",
    "content": " ",
    "url": "/all-ops/user/signuporganizationmember",
    
    "relUrl": "/all-ops/user/signuporganizationmember"
  },"208": {
    "doc": "/orderStrategy/startOrderStrategy",
    "title": "/orderStrategy/startOrderStrategy",
    "content": " ",
    "url": "/all-ops/orderstrategy/startorderstrategy",
    
    "relUrl": "/all-ops/orderstrategy/startorderstrategy"
  },"209": {
    "doc": "/suggest",
    "title": "/{entity}/suggest",
    "content": "The /suggest operation returns up to l entities that match the query text t. This is useful for when you want to make a choice, or find out what is available, eg. /contract/suggest?t=ES&amp;l=10 will return the 10 most relevant ES contracts. ",
    "url": "/all-ops/shared/suggest#entitysuggest",
    
    "relUrl": "/all-ops/shared/suggest#entitysuggest"
  },"210": {
    "doc": "/suggest",
    "title": "Format",
    "content": "For HTTP requests, we can use this format: . https://live.tradovateapi.com/v1/{entity}/suggest?l=&lt;max_results&gt;&amp;t=&lt;query_text&gt; OR https://demo.tradovateapi.com/v1/{entity}/suggest?l=&lt;max_results&gt;&amp;t=&lt;query_text&gt; . And for WebSocket requests: . &lt;entity&gt;/suggest &lt;msg_id&gt; l=&lt;max_results&gt;&amp;t=&lt;query_text&gt; . Example Usage: . async function entitySuggest(entityType, text, maxLength = 10) { const URL = `https://demo.tradovateapi.com/v1/${entityType}/suggest?t=${text}&amp;l=${maxLength}` let response, data try { response = await fetch(URL) data = await response.json() } catch(err) { console.error(err) } return data } await entitySuggest('contract', 'ES') //=&gt; // [ // { // \"id\": 2710963, // \"name\": \"ESM2\", // \"contractMaturityId\": 46104, // \"status\": \"DefinitionChecked\", // \"providerTickSize\": 0.25 // }, // { // \"id\": 2830505, // \"name\": \"ESU2\", // \"contractMaturityId\": 46575, // \"status\": \"DefinitionChecked\", // \"providerTickSize\": 0.25 // }, // { // \"id\": 2830506, // \"name\": \"ESZ2\", // \"contractMaturityId\": 46576, // \"status\": \"DefinitionChecked\", // \"providerTickSize\": 0.25 // }, // //... // ] . ",
    "url": "/all-ops/shared/suggest#format",
    
    "relUrl": "/all-ops/shared/suggest#format"
  },"211": {
    "doc": "/suggest",
    "title": "/suggest",
    "content": " ",
    "url": "/all-ops/shared/suggest",
    
    "relUrl": "/all-ops/shared/suggest"
  },"212": {
    "doc": "/accountRiskStatus/switchRiskCategory",
    "title": "/accountRiskStatus/switchRiskCategory",
    "content": " ",
    "url": "/all-ops/accountriskstatus/switchriskcategory",
    
    "relUrl": "/all-ops/accountriskstatus/switchriskcategory"
  },"213": {
    "doc": "TradeDate",
    "title": "TradeDate",
    "content": "An object that represents the date of a trade session by its year, month and day. Related . | CashBalance | CashBalanceLog | ExecutionReport | Fill | Position | . Definition . | Property | Tags | Type | Remarks | . | year | required | number, int32 |   | . | month | required | number, int32 |   | . | day | required | number, int32 |   | . ",
    "url": "/entity-system/entity-index/tradedate",
    
    "relUrl": "/entity-system/entity-index/tradedate"
  },"214": {
    "doc": "TradeTime",
    "title": "TradeTime",
    "content": "Object that represents an open or close time for a market by its hour and minute values. Definition . | Property | Tags | Type | Remarks | . | hour | required | number, int32 |   | . | minute | required | number, int32 |   | . ",
    "url": "/entity-system/entity-index/tradetime",
    
    "relUrl": "/entity-system/entity-index/tradetime"
  },"215": {
    "doc": "TradingPermission",
    "title": "TradingPermission",
    "content": "An object that represents a permission that has been granted from one User to another to trade that user’s Account. Related . | Account | /user/requestTradingPermission | /user/acceptTradingPermission | . Definition . | Property | Tags | Type | Remarks | . | id | none | number, int64 |   | . | userId | required | number, int64 | User to grant the TradingPermission. | . | accountId | required | number, int64 | Account entity owned by the caller for which to grant permission. | . | accountHolderContact | required | string &lt;= 64 chars | Full name of the original Account holder. | . | accountHolderEmail | required | string &lt;= 64 chars | Email address of the original Account holder. | . | ctaContact | required | string &lt;= 64 chars | Full name of the user being granted permission. | . | ctaEmail | required | string &lt;= 64 chars | Email address of the user being granted permission. | . | updated | none | Date string |   | . | approvedById | none | number, int64 | ID of approving User. | . ",
    "url": "/entity-system/entity-index/tradingpermission",
    
    "relUrl": "/entity-system/entity-index/tradingpermission"
  },"216": {
    "doc": "TradovateSubscription",
    "title": "TradovateSubscription",
    "content": "An object that represents an instance of a subscription defined by a TradovateSubscriptionPlan entity. Related . | TradovateSubscriptionPlan | /user/addTradovateSubscription | /user/cancelTradovateSubscription | . Definition . | Property | Tags | Type | Remarks | . | id | none | number, int64 |   | . | userId | required | number, int64 | ID of the User holding this TradovateSubscription. | . | timestamp | required | string Date | JSON encoded Date string representing the creation time. | . | planPrice | required | number, double | Price value of the TradovateSubscription. | . | tradovateSubscriptionPlanId | required | number, int64 | ID of the TradovateSubscriptionPlan entity associated with this TradovateSubscription instance. | . | startDate | required | TradeDate | The TradeDate date object representing the day, month, and year that this TradovateSubscription started. | . | expirationDate | required | TradeDate | The TradeDate date object representing the day, month, and year that this TradovateSubscription ended or will end. | . | paidAmount | required | number, double | Amount representing the value invested in the subscription’s purchase. For Vendor subscriptions, this value will typically be 0. This is because of the way we measure monthly active users, and instead a statement is generated monthly. | . | creditCardTransactionId | none | number, int64 | ID of the corresponding credit card transaction, if applicable. | . | cashBalanceLogId | none | number, int64 | If a Tradovate account was used to make this purchase, a CashBalanceLog will be generated. | . | creditCardId | none | number, int64 | If a credit card was used to make the purchase of this plan, its ID will be non-null. | . | accountId | none | number, int64 | If a Tradovate account was used to make this purchase, the Account entity’s ID will be non-null. | . | cancelledRenewal | none | boolean | true when the auto-renewal has been cancelled for this subscription. | . | cancelReason | none | string | A provided text reason for the cancellation, provided when calling /user/cancelTradovateSubscription. | . ",
    "url": "/entity-system/entity-index/tradovatesubscription",
    
    "relUrl": "/entity-system/entity-index/tradovatesubscription"
  },"217": {
    "doc": "/contactInfo/updateContactInfo",
    "title": "/contactInfo/updateContactInfo",
    "content": " ",
    "url": "/all-ops/contactinfo/updatecontactinfo",
    
    "relUrl": "/all-ops/contactinfo/updatecontactinfo"
  },"218": {
    "doc": "/accountRiskStatus/updateMaxNetLiq",
    "title": "/accountRiskStatus/updateMaxNetLiq",
    "content": " ",
    "url": "/all-ops/accountriskstatus/updatemaxnetliq",
    
    "relUrl": "/all-ops/accountriskstatus/updatemaxnetliq"
  },"219": {
    "doc": "User",
    "title": "User",
    "content": "Represents a Tradovate User. Definition . | Property | Tags | Type | Remarks | . | id | none | number, int64 | This is probably the most useful property for a typical client. You’ll need your userId to call other endpoints. | . | name | required | string [3..64] chars |   | . | timestamp | required | Date string |   | . | email | required | string &lt;= 64 chars |   | . | status | required | string enum, \"Active\" \"Closed\" \"Initiated\" \"TemporaryLocked\" \"UnconfirmedEmail\" |   | . | professional | required | boolean |   | . | organizationId | none | number, int64 |   | . | linkedUserId | none | number, int64 |   | . | foreignIntroducingBrokerId | none | number, int64 |   | . ",
    "url": "/entity-system/entity-index/user",
    
    "relUrl": "/entity-system/entity-index/user"
  },"220": {
    "doc": "UserAccountAutoLiq",
    "title": "UserAccountAutoLiq",
    "content": "An object that represents the auto-liquidation rules for an account. Related . | Account | UserAccountPositionLimit | UserAccountRiskParameter | /userAccountAutoLiq/update | . Definition . | Property | Tags | Type | Remarks | . | id | none | number, int64 |   | . | changesLocked | none | boolean |   | . | marginPercentageAlert | none | number, double | Percent Margin consumed before producing an Alert | . | dailyLossPercentageAlert | none | number, double | Percent of balance lost before producing an Alert. | . | dailyLossAlert | none | number, double | Currency value loss before producing an Alert. | . | marginPercentageLiqOnly | none | number, double | Same as marginPercentageAlert but puts the Account in Liquidate-Only Mode instead of producing an Alert. | . | dailyLossPercentageLiqOnly | none | number, double | Same as dailyLossPercentageAlert but puts the Account in Liquidate-Only Mode instead of producing an Alert. | . | dailyLossLiqOnly | none | number, double | Same as dailyLossAlert but puts the Account in Liquidate-Only Mode instead of producing an Alert. | . | marginPercentAutoLiq | none | number, double | Same as marginPercentageAlert and marginPercentageLiqOnly, but Auto-Liquidates the Account instead of producing an Alert or placing the account into Liquidate Only Mode. | . | dailyLossPercentageAutoLiq | none | number, double | Same as dailyLossPercentageAlert and dailyLossPercentageLiqOnly, but Auto-Liquidates the Account instead of producing an Alert or placing the account into Liquidate Only Mode. | . | dailyLossAutoLiq | none | number, double | Same as dailyLossAlert and dailyLossLiqOnly, but Auto-Liquidates the Account instead of producing an Alert or placing the account into Liquidate Only Mode. | . | weeklyLossAutoLiq | none | number, double | Currency value loss during the week required to trigger an Auto-Liquidation. | . | flattenTimestamp | none | Date string | This useful risk management parameter can force you into a flat position at the given time. This means regardless of the state of a trade, at time flattenTimestamp, your account will attempt to flatten any open positions. | . | trailingMaxDrawdown | none | number, double | The maximum currency value below the starting balance that your account will be allowed to fall under before being auto-liquidated. This value trails profit, but stops once the trailing drawdown is equal to the original balance. This means Trailing Max Drawdown always exists within the following range: (orginalBalance - trailingDDBaseValue) &lt;= trailingDD &lt;= originalBalance | . | trailingMaxDrawdownLimit | none | number, double | Stop drawdown at a certain value. | . | trailingMaxDrawdownMode | none | string enum, \"EOD\" \"Realtime\" | Calculate trailing Max Drawdown at End-of-Day, or in Realtime? | . | dailyProfitAutoLiq | none | number, double | Currency value amount of daily profit before Auto-Liquidating the Account. | . | weeklyProfitAutoLiq | none | number, double | Currency value amount of weekly profit before Auto-Liquidating the Account. | . | doNotUnlock | none | number, double | PERMANENTLY lock the account if auto-liq settings are hit. | . ",
    "url": "/entity-system/entity-index/useraccountautoliq",
    
    "relUrl": "/entity-system/entity-index/useraccountautoliq"
  },"221": {
    "doc": "/userAccountAutoLiq/update",
    "title": "/userAccountAutoLiq/update",
    "content": " ",
    "url": "/all-ops/useraccountautoliq/update",
    
    "relUrl": "/all-ops/useraccountautoliq/update"
  },"222": {
    "doc": "UserAccountPositionLimit",
    "title": "UserAccountPositionLimit",
    "content": "An object that represents a Position Limit. This object can be parameterized by its sister-object, AccountRiskParameter. Related . | UserAccountRiskParameter | AccountRiskStatus | Account | . Definition . | Property | Tags | Type | Remarks | . | id | none | number, int64 |   | . | contractId | none | number, int64 | Entity ID of a Contract that this Position Limit should apply to. | . | productId | none | number, int64 | Entity ID of a Product that this Position Limit should apply to. | . | exchangeId | none | number, int64 | Entity ID of an Exchange that this Position Limit should apply to. | . | productType | none | string enum, \"CommonStock\", \"Continuous\", \"Cryptocurrency\", \"Futures\", \"MarketInternals\", \"Options\", \"Spread\" |   | . | riskDiscountContractGroupId | none | number, int64 |   | . | productVerificationStatus | none | string enum, \"Inactive\", \"Locked\", \"ReadyForContracts\", \"ReadyToTrade\", \"Verified\" |   | . | contractGroupId | none | number, int64 |   | . | active | required | boolean |   | . | riskTimePeriodId | none | number, int64 |   | . | totalBy | required | string enum, \"Contract\", \"ContractGroup\", \"DiscountGroup\", \"Exchange\", \"Overall\", \"Product\", \"ProductType\" | The method used to total this Position Limit’s longLimit, shortLimit or total exposedLimit fields. If using \"Contract\" for example, an exposedLimit of 10 would allow you to to hold a max position of +/- 10 contracts. | . | shortLimit | none | number, int32 |   | . | longLimit | none | number, int32 |   | . | exposedLimit | none | number, int32 |   | . | description | none | string &lt;= 64 chars | Optional string to describe this Position Limit. | . | accountId | required | number, int64 |   | . ",
    "url": "/entity-system/entity-index/useraccountpositionlimit",
    
    "relUrl": "/entity-system/entity-index/useraccountpositionlimit"
  },"223": {
    "doc": "/userAccountPositionLimit/create",
    "title": "/userAccountPositionLimit/create",
    "content": " ",
    "url": "/all-ops/risks/useraccountpositionlimit/create",
    
    "relUrl": "/all-ops/risks/useraccountpositionlimit/create"
  },"224": {
    "doc": "/userAccountPositionLimit/update",
    "title": "/userAccountPositionLimit/update",
    "content": " ",
    "url": "/all-ops/risks/useraccountpositionlimitupdate",
    
    "relUrl": "/all-ops/risks/useraccountpositionlimitupdate"
  },"225": {
    "doc": "UserAccountRiskParameter",
    "title": "UserAccountRiskParameter",
    "content": "This entity is used to parameterize an UserAccountPositionLimit. Related . | UserAccountPositionLimit | AccountRiskStatus | Account | . Definition . | Property | Tags | Type | Remarks | . | id | none | number, int64 | AccountRiskParameter entity ID. | . | contractId | none | number, int64 | Used to declare that this risk parameter should be applied to the Contract with this ID. | . | productId | none | number, int64 | Used to declare that this risk parameter should be applied to the Product with this ID. | . | exchangeId | none | number, int64 | Used to declare that this risk parameter should be applied to the Exchange with this ID. | . | productType | none | string enum, \"CommonStock\", \"Continuous\", \"Cryptocurrency\", \"Futures\", \"MarketInternals\", \"Options\", \"Spread\" | Overarching Product Type that is the target for this risk parameter. See Product. | . | riskDiscountContractGroupId | none | number, int64 |   | . | productVerificationStatus | none | string enum, \"Inactive\", \"Locked\", \"ReadyForContracts\", \"ReadyToTrade\", \"Verified\" |   | . | contractGroupId | none | number, int64 |   | . | maxOpeningOrderQty | none | number, int32 | Controls the number of positions that can be opened at a time. For example a maxOpeningOrderQty of 1 would only allow the user place 1 order at a time, but up to whatever the exposedLimit, longLimit or shortLimit on the Position Limit entity is. For a user in the default risk category the maxOpeningOrderQty defaults to 100, allowing a user to place up to 100 orders in a single move if that user has margin eligibility to do so for the contract being traded. | . | maxClosingOrderQty | none | number, int32 | Works just like maxOpeningOrderQty, but instead for placing orders to close positions. This value also defaults to 100 for default risk category users. | . | maxBackMonth | none | number, int32 | Controls the maximum number of months prior to the expiration of a contract that you can trade that contract. | . | preExpirationDays | none | number, int32 | Controls the maximum number of days before a contract’s expiration before you must roll forward. Does not mandate that you roll forward but you will fail to pass risk settings when trying to place a trade in fewer than preExpirationDays days prior to the contract’s expiration. | . | marginPercentage | none | number, double | The maximum percentage of your available margin that you may consume before failing risk on new orders. | . | marginDollarValue | none | number, double | The maximum currency value that you will be allowed to margin for trades, after which you will fail at risk on new orders. | . | hardLimit | none | boolean |   | . | userAccountPositionLimitId | required | number, int64 | The ID of the associated UserAccountPositionLimit entity for this Risk parameter. | . ",
    "url": "/entity-system/entity-index/useraccountriskparameter",
    
    "relUrl": "/entity-system/entity-index/useraccountriskparameter"
  },"226": {
    "doc": "/userAccountRiskParameter/create",
    "title": "/userAccountRiskParameter/create",
    "content": " ",
    "url": "/all-ops/risks/useraccountriskparametercreate",
    
    "relUrl": "/all-ops/risks/useraccountriskparametercreate"
  },"227": {
    "doc": "/userAccountRiskParameter/update",
    "title": "/userAccountRiskParameter/update",
    "content": " ",
    "url": "/all-ops/risks/useraccountriskparameterupdate",
    
    "relUrl": "/all-ops/risks/useraccountriskparameterupdate"
  },"228": {
    "doc": "UserPlugin",
    "title": "UserPlugin",
    "content": "An object that represents a purchasable plugin. Related . | Entitlement | EntitlementSubscription | /userPlugin/addEntitlementSubscription | . Definition . | Property | Tags | Type | Remarks | . | id | none | number, int64 |   | . | userId | required | number, int64 |   | . ",
    "url": "/entity-system/entity-index/userplugin",
    
    "relUrl": "/entity-system/entity-index/userplugin"
  },"229": {
    "doc": "user/syncRequest",
    "title": "user/syncRequest",
    "content": ". | This operation is used to open a real-time stream to all user-related actions. | The opened stream will transmit any updates or changes that have a relationship to your user. | . Example . const mySocket = new WebSocket('wss://demo.tradovateapi.com/v1/websocket') //... // perform the auth procedure... //... //get your userId whatever way you like, here I use one of the local lib's Storage features. const { userId } = Storage.getUserData(); mySocket.send(`user/syncrequest\\n1\\n\\n${JSON.stringify({ users: [userId] })}`) mysocket.onmessage = msg =&gt; { const T = msg.data.split(0,1) //first char is frame type let data = msg.data.split(1) //data is rest if(data) { //parse to JSON, all data arrives as a string representation of a JSON array data = JSON.parse(data) } //'a' is the data frame type if(T === 'a') { //if you have dual-connections purchased, it is fun to //run this websocket while you make actions on the Trader //application. You will see everything you do in real-time! console.log(data) } } . Notes . | If you are a B2B Organization Vendor, please be sure to add the splitResponses field to your request body! Failure to do so will result in the connection being immediately terminated without obvious logging. mySocket.send(`user/syncrequest\\n1\\n\\n${JSON.stringify({ users: [orgAdminId], splitResponses: true })}`) . | . ",
    "url": "/all-ops/websockets/syncRequest",
    
    "relUrl": "/all-ops/websockets/syncRequest"
  },"230": {
    "doc": "Users",
    "title": "Users",
    "content": " ",
    "url": "/all-ops/user",
    
    "relUrl": "/all-ops/user"
  },"231": {
    "doc": "WebSocket Playground",
    "title": "WebSocket Playground",
    "content": "wss://demo-d.tradovateapi.com/v1/websocket wss://live-d.tradovateapi.com/v1/websocket wss://md-d.tradovateapi.com/v1/websocket wss://replay-d.tradovateapi.com/v1/websocket Connect OUTPUT . INPUT . Generate Message Send Show Heartbeats PARAMS . COMMAND PALETTE . ",
    "url": "/all-ops/websockets/play#websocket-playground",
    
    "relUrl": "/all-ops/websockets/play#websocket-playground"
  },"232": {
    "doc": "WebSocket Playground",
    "title": "WebSocket Playground",
    "content": " ",
    "url": "/all-ops/websockets/play",
    
    "relUrl": "/all-ops/websockets/play"
  },"233": {
    "doc": "WebSockets",
    "title": "WebSockets",
    "content": " ",
    "url": "/all-ops/websockets",
    
    "relUrl": "/all-ops/websockets"
  },"234": {
    "doc": "Market Replay",
    "title": "Market Replay",
    "content": "Market Replay service allows an API subscriber to start a replay session. A replay session picks a time from the past and plays back the market as it happened at up to 400% of real-time. Additionally, each replay session has an associated sim account generated for the session that you can use for backtesting a strategy, or playing back and analyzing your own trades. This service is available by connecting a WebSocket to wss://replay.tradovateapi.com/v1/websocket. ",
    "url": "/wss-guide/market-replay",
    
    "relUrl": "/wss-guide/market-replay"
  },"235": {
    "doc": "Market Replay",
    "title": "Notes",
    "content": ". | The Replay Socket is heavily tied to the Market Data socket protocol, as this is where the historic market data you are analyzing will be made available via API. In order to utilize market data through the API, you must first become a registered subvendor of CME Market Data. | A Replay Socket follows the same protocols and authorization procedure as a Live/Demo socket or an MD socket. | You should treat a WebSocket connected to the Replay API as if it were connected to both a Live or Demo WebSocket and a Market Data WebSocket. This means you can send both REST-like requests and MD requests to the same Replay socket instance. | . ",
    "url": "/wss-guide/market-replay#notes",
    
    "relUrl": "/wss-guide/market-replay#notes"
  }
}
